// Package apigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package apigen

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

const (
	Basic_authScopes  = "basic_auth.Scopes"
	Cookie_authScopes = "cookie_auth.Scopes"
	Jwt_tokenScopes   = "jwt_token.Scopes"
	Oidc_authScopes   = "oidc_auth.Scopes"
	Saml_authScopes   = "saml_auth.Scopes"
)

// ACL defines model for ACL.
type ACL struct {

	// Permission level to give this ACL.  "Read", "Write", "Super" and
	// "Admin" are all supported.
	Permission string `json:"permission"`
}

// AbortPresignMultipartUpload defines model for AbortPresignMultipartUpload.
type AbortPresignMultipartUpload struct {
	PhysicalAddress string `json:"physical_address"`
}

// AccessKeyCredentials defines model for AccessKeyCredentials.
type AccessKeyCredentials struct {

	// access key ID to set for user for use in integration testing.
	AccessKeyId string `json:"access_key_id"`

	// secret access key to set for user for use in integration testing.
	SecretAccessKey string `json:"secret_access_key"`
}

// ActionRun defines model for ActionRun.
type ActionRun struct {
	Branch    string     `json:"branch"`
	CommitId  string     `json:"commit_id"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	EventType string     `json:"event_type"`
	RunId     string     `json:"run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// ActionRunList defines model for ActionRunList.
type ActionRunList struct {
	Pagination Pagination  `json:"pagination"`
	Results    []ActionRun `json:"results"`
}

// AuthCapabilities defines model for AuthCapabilities.
type AuthCapabilities struct {
	ForgotPassword *bool `json:"forgot_password,omitempty"`
	InviteUser     *bool `json:"invite_user,omitempty"`
}

// AuthenticationToken defines model for AuthenticationToken.
type AuthenticationToken struct {

	// a JWT token that could be used to authenticate requests
	Token string `json:"token"`

	// Unix Epoch in seconds
	TokenExpiration *int64 `json:"token_expiration,omitempty"`
}

// BranchCreation defines model for BranchCreation.
type BranchCreation struct {
	Force  *bool  `json:"force,omitempty"`
	Name   string `json:"name"`
	Source string `json:"source"`
}

// BranchProtectionRule defines model for BranchProtectionRule.
type BranchProtectionRule struct {

	// fnmatch pattern for the branch name, supporting * and ? wildcards
	Pattern string `json:"pattern"`
}

// CherryPickCreation defines model for CherryPickCreation.
type CherryPickCreation struct {
	Force *bool `json:"force,omitempty"`

	// When cherry-picking a merge commit, the parent number (starting from 1) with which to perform the diff.
	// The default branch is parent 1.
	ParentNumber *int `json:"parent_number,omitempty"`

	// the commit to cherry-pick, given by a ref
	Ref string `json:"ref"`
}

// CommPrefsInput defines model for CommPrefsInput.
type CommPrefsInput struct {

	// the provided email
	Email *string `json:"email,omitempty"`

	// user preference to receive feature updates
	FeatureUpdates bool `json:"featureUpdates"`

	// user preference to receive security updates
	SecurityUpdates bool `json:"securityUpdates"`
}

// Commit defines model for Commit.
type Commit struct {
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64            `json:"creation_date"`
	Generation   *int64           `json:"generation,omitempty"`
	Id           string           `json:"id"`
	Message      string           `json:"message"`
	MetaRangeId  string           `json:"meta_range_id"`
	Metadata     *Commit_Metadata `json:"metadata,omitempty"`
	Parents      []string         `json:"parents"`
	Version      *int             `json:"version,omitempty"`
}

// Commit_Metadata defines model for Commit.Metadata.
type Commit_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitCreation defines model for CommitCreation.
type CommitCreation struct {

	// sets whether a commit can contain no changes
	AllowEmpty *bool `json:"allow_empty,omitempty"`

	// set date to override creation date in the commit (Unix Epoch in seconds)
	Date     *int64                   `json:"date,omitempty"`
	Force    *bool                    `json:"force,omitempty"`
	Message  string                   `json:"message"`
	Metadata *CommitCreation_Metadata `json:"metadata,omitempty"`
}

// CommitCreation_Metadata defines model for CommitCreation.Metadata.
type CommitCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CommitList defines model for CommitList.
type CommitList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Commit   `json:"results"`
}

// CommitRecordCreation defines model for CommitRecordCreation.
type CommitRecordCreation struct {

	// id of the commit record
	CommitId string `json:"commit_id"`

	// committer of the commit record
	Committer string `json:"committer"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
	Force        *bool `json:"force,omitempty"`

	// generation of the commit record
	Generation int64 `json:"generation"`

	// message of the commit record
	Message string `json:"message"`

	// metadata of the commit record
	Metadata *CommitRecordCreation_Metadata `json:"metadata,omitempty"`

	// metarange_id of the commit record
	MetarangeId string `json:"metarange_id"`

	// parents of the commit record
	Parents []string `json:"parents"`

	// version of the commit record
	Version int `json:"version"`
}

// CommitRecordCreation_Metadata defines model for CommitRecordCreation.Metadata.
type CommitRecordCreation_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// CompletePresignMultipartUpload defines model for CompletePresignMultipartUpload.
type CompletePresignMultipartUpload struct {

	// Object media type
	ContentType *string `json:"content_type,omitempty"`

	// List of uploaded parts, should be ordered by ascending part number
	Parts           []UploadPart                                 `json:"parts"`
	PhysicalAddress string                                       `json:"physical_address"`
	UserMetadata    *CompletePresignMultipartUpload_UserMetadata `json:"user_metadata,omitempty"`
}

// CompletePresignMultipartUpload_UserMetadata defines model for CompletePresignMultipartUpload.UserMetadata.
type CompletePresignMultipartUpload_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Config defines model for Config.
type Config struct {
	StorageConfig *StorageConfig `json:"storage_config,omitempty"`
	VersionConfig *VersionConfig `json:"version_config,omitempty"`
}

// Credentials defines model for Credentials.
type Credentials struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`
}

// CredentialsList defines model for CredentialsList.
type CredentialsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []Credentials `json:"results"`
}

// CredentialsWithSecret defines model for CredentialsWithSecret.
type CredentialsWithSecret struct {
	AccessKeyId string `json:"access_key_id"`

	// Unix Epoch in seconds
	CreationDate    int64  `json:"creation_date"`
	SecretAccessKey string `json:"secret_access_key"`
}

// CurrentUser defines model for CurrentUser.
type CurrentUser struct {
	User User `json:"user"`
}

// Diff defines model for Diff.
type Diff struct {
	Path     string `json:"path"`
	PathType string `json:"path_type"`

	// represents the size of the added/changed/deleted entry
	SizeBytes *int64 `json:"size_bytes,omitempty"`
	Type      string `json:"type"`
}

// DiffList defines model for DiffList.
type DiffList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Diff     `json:"results"`
}

// Error defines model for Error.
type Error struct {

	// short message explaining the error
	Message string `json:"message"`
}

// ErrorNoACL defines model for ErrorNoACL.
type ErrorNoACL struct {

	// short message explaining the error
	Message string `json:"message"`

	// true if the group exists but has no ACL
	NoAcl *bool `json:"no_acl,omitempty"`
}

// FindMergeBaseResult defines model for FindMergeBaseResult.
type FindMergeBaseResult struct {

	// The commit ID of the merge base
	BaseCommitId string `json:"base_commit_id"`

	// The commit ID of the merge destination
	DestinationCommitId string `json:"destination_commit_id"`

	// The commit ID of the merge source
	SourceCommitId string `json:"source_commit_id"`
}

// GarbageCollectionConfig defines model for GarbageCollectionConfig.
type GarbageCollectionConfig struct {

	// Duration in seconds. Objects created in the recent grace_period will not be collected.
	GracePeriod *int `json:"grace_period,omitempty"`
}

// GarbageCollectionPrepareResponse defines model for GarbageCollectionPrepareResponse.
type GarbageCollectionPrepareResponse struct {

	// location to use for expired addresses parquet table (partitioned by run_id)
	GcAddressesLocation string `json:"gc_addresses_location"`

	// location of the resulting commits csv table (partitioned by run_id)
	GcCommitsLocation string `json:"gc_commits_location"`

	// a presigned url to download the commits csv
	GcCommitsPresignedUrl *string `json:"gc_commits_presigned_url,omitempty"`

	// a unique identifier generated for this GC job
	RunId string `json:"run_id"`
}

// GarbageCollectionRule defines model for GarbageCollectionRule.
type GarbageCollectionRule struct {
	BranchId      string `json:"branch_id"`
	RetentionDays int    `json:"retention_days"`
}

// GarbageCollectionRules defines model for GarbageCollectionRules.
type GarbageCollectionRules struct {
	Branches             []GarbageCollectionRule `json:"branches"`
	DefaultRetentionDays int                     `json:"default_retention_days"`
}

// Group defines model for Group.
type Group struct {

	// Unix Epoch in seconds
	CreationDate int64   `json:"creation_date"`
	Id           string  `json:"id"`
	Name         *string `json:"name,omitempty"`
}

// GroupCreation defines model for GroupCreation.
type GroupCreation struct {
	Id string `json:"id"`
}

// GroupList defines model for GroupList.
type GroupList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Group    `json:"results"`
}

// HookRun defines model for HookRun.
type HookRun struct {
	Action    string     `json:"action"`
	EndTime   *time.Time `json:"end_time,omitempty"`
	HookId    string     `json:"hook_id"`
	HookRunId string     `json:"hook_run_id"`
	StartTime time.Time  `json:"start_time"`
	Status    string     `json:"status"`
}

// HookRunList defines model for HookRunList.
type HookRunList struct {
	Pagination Pagination `json:"pagination"`
	Results    []HookRun  `json:"results"`
}

// ImportCreation defines model for ImportCreation.
type ImportCreation struct {
	Commit CommitCreation   `json:"commit"`
	Force  *bool            `json:"force,omitempty"`
	Paths  []ImportLocation `json:"paths"`
}

// ImportCreationResponse defines model for ImportCreationResponse.
type ImportCreationResponse struct {

	// The id of the import process
	Id string `json:"id"`
}

// ImportLocation defines model for ImportLocation.
type ImportLocation struct {

	// Destination for the imported objects on the branch. Must be a relative path to the branch.
	// If the type is an 'object', the destination is the exact object name under the branch.
	// If the type is a 'common_prefix', the destination is the prefix under the branch.
	Destination string `json:"destination"`

	// A source location to a 'common_prefix' or to a single object. Must match the lakeFS installation blockstore type.
	Path string `json:"path"`

	// Path type, can either be 'common_prefix' or 'object'
	Type string `json:"type"`
}

// ImportStatus defines model for ImportStatus.
type ImportStatus struct {
	Commit    *Commit `json:"commit,omitempty"`
	Completed bool    `json:"completed"`
	Error     *Error  `json:"error,omitempty"`

	// Number of objects processed so far
	IngestedObjects *int64    `json:"ingested_objects,omitempty"`
	MetarangeId     *string   `json:"metarange_id,omitempty"`
	UpdateTime      time.Time `json:"update_time"`
}

// InstallationUsageReport defines model for InstallationUsageReport.
type InstallationUsageReport struct {
	InstallationId string        `json:"installation_id"`
	Reports        []UsageReport `json:"reports"`
}

// LoginConfig defines model for LoginConfig.
type LoginConfig struct {

	// RBAC will remain enabled on GUI if "external".  That only works
	// with an external auth service.
	RBAC *string `json:"RBAC,omitempty"`

	// label to place on fallback_login_url.
	FallbackLoginLabel *string `json:"fallback_login_label,omitempty"`

	// secondary URL to offer users to use for login.
	FallbackLoginUrl *string `json:"fallback_login_url,omitempty"`

	// cookie names used to store JWT
	LoginCookieNames []string `json:"login_cookie_names"`

	// message to display to users who fail to login; a full sentence that is rendered
	// in HTML and may contain a link to a secondary login method
	LoginFailedMessage *string `json:"login_failed_message,omitempty"`

	// primary URL to use for login.
	LoginUrl string `json:"login_url"`

	// URL to use for logging out.
	LogoutUrl string `json:"logout_url"`
}

// LoginInformation defines model for LoginInformation.
type LoginInformation struct {
	AccessKeyId     string `json:"access_key_id"`
	SecretAccessKey string `json:"secret_access_key"`
}

// Merge defines model for Merge.
type Merge struct {
	Force    *bool           `json:"force,omitempty"`
	Message  *string         `json:"message,omitempty"`
	Metadata *Merge_Metadata `json:"metadata,omitempty"`

	// In case of a merge conflict, this option will force the merge process to automatically favor changes from the dest branch ('dest-wins') or from the source branch('source-wins'). In case no selection is made, the merge process will fail in case of a conflict
	Strategy *string `json:"strategy,omitempty"`
}

// Merge_Metadata defines model for Merge.Metadata.
type Merge_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// MergeResult defines model for MergeResult.
type MergeResult struct {
	Reference string `json:"reference"`
}

// ObjectCopyCreation defines model for ObjectCopyCreation.
type ObjectCopyCreation struct {
	Force *bool `json:"force,omitempty"`

	// path of the copied object relative to the ref
	SrcPath string `json:"src_path"`

	// a reference, if empty uses the provided branch as ref
	SrcRef *string `json:"src_ref,omitempty"`
}

// ObjectError defines model for ObjectError.
type ObjectError struct {

	// short message explaining status_code
	Message string `json:"message"`

	// affected path
	Path *string `json:"path,omitempty"`

	// HTTP status code associated for operation on path
	StatusCode int `json:"status_code"`
}

// ObjectErrorList defines model for ObjectErrorList.
type ObjectErrorList struct {
	Errors []ObjectError `json:"errors"`
}

// ObjectStageCreation defines model for ObjectStageCreation.
type ObjectStageCreation struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Force       *bool               `json:"force,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime           *int64 `json:"mtime,omitempty"`
	PhysicalAddress string `json:"physical_address"`
	SizeBytes       int64  `json:"size_bytes"`
}

// ObjectStats defines model for ObjectStats.
type ObjectStats struct {
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string             `json:"content_type,omitempty"`
	Metadata    *ObjectUserMetadata `json:"metadata,omitempty"`

	// Unix Epoch in seconds
	Mtime    int64  `json:"mtime"`
	Path     string `json:"path"`
	PathType string `json:"path_type"`

	// The location of the object on the underlying object store.
	// Formatted as a native URI with the object store type as scheme ("s3://...", "gs://...", etc.)
	// Or, in the case of presign=true, will be an HTTP URL to be consumed via regular HTTP GET
	PhysicalAddress string `json:"physical_address"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PhysicalAddressExpiry *int64 `json:"physical_address_expiry,omitempty"`
	SizeBytes             *int64 `json:"size_bytes,omitempty"`
}

// ObjectStatsList defines model for ObjectStatsList.
type ObjectStatsList struct {
	Pagination Pagination    `json:"pagination"`
	Results    []ObjectStats `json:"results"`
}

// ObjectUserMetadata defines model for ObjectUserMetadata.
type ObjectUserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Pagination defines model for Pagination.
type Pagination struct {

	// Next page is available
	HasMore bool `json:"has_more"`

	// Maximal number of entries per page
	MaxPerPage int `json:"max_per_page"`

	// Token used to retrieve the next page
	NextOffset string `json:"next_offset"`

	// Number of values found in the results
	Results int `json:"results"`
}

// PathList defines model for PathList.
type PathList struct {
	Paths []string `json:"paths"`
}

// Policy defines model for Policy.
type Policy struct {

	// Unix Epoch in seconds
	CreationDate *int64      `json:"creation_date,omitempty"`
	Id           string      `json:"id"`
	Statement    []Statement `json:"statement"`
}

// PolicyList defines model for PolicyList.
type PolicyList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Policy   `json:"results"`
}

// PrepareGCUncommittedRequest defines model for PrepareGCUncommittedRequest.
type PrepareGCUncommittedRequest struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`
}

// PrepareGCUncommittedResponse defines model for PrepareGCUncommittedResponse.
type PrepareGCUncommittedResponse struct {
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// location of uncommitted information data
	GcUncommittedLocation string `json:"gc_uncommitted_location"`
	RunId                 string `json:"run_id"`
}

// PresignMultipartUpload defines model for PresignMultipartUpload.
type PresignMultipartUpload struct {
	PhysicalAddress string    `json:"physical_address"`
	PresignedUrls   *[]string `json:"presigned_urls,omitempty"`
	UploadId        string    `json:"upload_id"`
}

// Ref defines model for Ref.
type Ref struct {
	CommitId string `json:"commit_id"`
	Id       string `json:"id"`
}

// RefList defines model for RefList.
type RefList struct {
	Pagination Pagination `json:"pagination"`
	Results    []Ref      `json:"results"`
}

// RefsDump defines model for RefsDump.
type RefsDump struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// RefsRestore defines model for RefsRestore.
type RefsRestore struct {
	BranchesMetaRangeId string `json:"branches_meta_range_id"`
	CommitsMetaRangeId  string `json:"commits_meta_range_id"`
	Force               *bool  `json:"force,omitempty"`
	TagsMetaRangeId     string `json:"tags_meta_range_id"`
}

// Repository defines model for Repository.
type Repository struct {

	// Unix Epoch in seconds
	CreationDate  int64  `json:"creation_date"`
	DefaultBranch string `json:"default_branch"`
	Id            string `json:"id"`

	// Whether the repository is a read-only repository- not relevant for bare repositories
	ReadOnly *bool `json:"read_only,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryCreation defines model for RepositoryCreation.
type RepositoryCreation struct {
	DefaultBranch *string `json:"default_branch,omitempty"`
	Name          string  `json:"name"`
	ReadOnly      *bool   `json:"read_only,omitempty"`
	SampleData    *bool   `json:"sample_data,omitempty"`

	// Filesystem URI to store the underlying data in (e.g. "s3://my-bucket/some/path/")
	StorageNamespace string `json:"storage_namespace"`
}

// RepositoryDumpStatus defines model for RepositoryDumpStatus.
type RepositoryDumpStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	Refs       *RefsDump `json:"refs,omitempty"`
	UpdateTime time.Time `json:"update_time"`
}

// RepositoryList defines model for RepositoryList.
type RepositoryList struct {
	Pagination Pagination   `json:"pagination"`
	Results    []Repository `json:"results"`
}

// RepositoryMetadata defines model for RepositoryMetadata.
type RepositoryMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryMetadataKeys defines model for RepositoryMetadataKeys.
type RepositoryMetadataKeys struct {
	Keys []string `json:"keys"`
}

// RepositoryMetadataSet defines model for RepositoryMetadataSet.
type RepositoryMetadataSet struct {
	Metadata RepositoryMetadataSet_Metadata `json:"metadata"`
}

// RepositoryMetadataSet_Metadata defines model for RepositoryMetadataSet.Metadata.
type RepositoryMetadataSet_Metadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// RepositoryRestoreStatus defines model for RepositoryRestoreStatus.
type RepositoryRestoreStatus struct {
	Done  bool    `json:"done"`
	Error *string `json:"error,omitempty"`

	// ID of the task
	Id         string    `json:"id"`
	UpdateTime time.Time `json:"update_time"`
}

// ResetCreation defines model for ResetCreation.
type ResetCreation struct {
	Force *bool   `json:"force,omitempty"`
	Path  *string `json:"path,omitempty"`

	// What to reset according to path.
	Type string `json:"type"`
}

// RevertCreation defines model for RevertCreation.
type RevertCreation struct {

	// allow empty commit (revert without changes)
	AllowEmpty *bool `json:"allow_empty,omitempty"`
	Force      *bool `json:"force,omitempty"`

	// when reverting a merge commit, the parent number (starting from 1) relative to which to perform the revert.
	ParentNumber int `json:"parent_number"`

	// the commit to revert, given by a ref
	Ref string `json:"ref"`
}

// Setup defines model for Setup.
type Setup struct {
	Key *AccessKeyCredentials `json:"key,omitempty"`

	// an identifier for the user (e.g. jane.doe)
	Username string `json:"username"`
}

// SetupState defines model for SetupState.
type SetupState struct {

	// true if the comm prefs are missing.
	CommPrefsMissing *bool        `json:"comm_prefs_missing,omitempty"`
	LoginConfig      *LoginConfig `json:"login_config,omitempty"`
	State            *string      `json:"state,omitempty"`
}

// StagingLocation defines model for StagingLocation.
type StagingLocation struct {
	PhysicalAddress *string `json:"physical_address,omitempty"`

	// if presign=true is passed in the request, this field will contain a pre-signed URL to use when uploading
	PresignedUrl *string `json:"presigned_url"`

	// If present and nonzero, physical_address is a pre-signed URL and
	// will expire at this Unix Epoch time.  This will be shorter than
	// the pre-signed URL lifetime if an authentication token is about
	// to expire.
	//
	// This field is *optional*.
	PresignedUrlExpiry *int64 `json:"presigned_url_expiry,omitempty"`
}

// StagingMetadata defines model for StagingMetadata.
type StagingMetadata struct {

	// unique identifier of object content on backing store (typically ETag)
	Checksum string `json:"checksum"`

	// Object media type
	ContentType *string `json:"content_type,omitempty"`
	Force       *bool   `json:"force,omitempty"`
	SizeBytes   int64   `json:"size_bytes"`

	// location for placing an object when staging it
	Staging      StagingLocation               `json:"staging"`
	UserMetadata *StagingMetadata_UserMetadata `json:"user_metadata,omitempty"`
}

// StagingMetadata_UserMetadata defines model for StagingMetadata.UserMetadata.
type StagingMetadata_UserMetadata struct {
	AdditionalProperties map[string]string `json:"-"`
}

// Statement defines model for Statement.
type Statement struct {
	Action   []string `json:"action"`
	Effect   string   `json:"effect"`
	Resource string   `json:"resource"`
}

// StatsEvent defines model for StatsEvent.
type StatsEvent struct {

	// stats event class (e.g. "s3_gateway", "openapi_request", "experimental-feature", "ui-event")
	Class string `json:"class"`

	// number of events of the class and name
	Count int `json:"count"`

	// stats event name (e.g. "put_object", "create_repository", "<experimental-feature-name>")
	Name string `json:"name"`
}

// StatsEventsList defines model for StatsEventsList.
type StatsEventsList struct {
	Events []StatsEvent `json:"events"`
}

// StorageConfig defines model for StorageConfig.
type StorageConfig struct {
	BlockstoreNamespaceValidityRegex string  `json:"blockstore_namespace_ValidityRegex"`
	BlockstoreNamespaceExample       string  `json:"blockstore_namespace_example"`
	BlockstoreType                   string  `json:"blockstore_type"`
	DefaultNamespacePrefix           *string `json:"default_namespace_prefix,omitempty"`
	ImportSupport                    bool    `json:"import_support"`
	ImportValidityRegex              string  `json:"import_validity_regex"`
	PreSignMultipartUpload           *bool   `json:"pre_sign_multipart_upload,omitempty"`
	PreSignSupport                   bool    `json:"pre_sign_support"`
	PreSignSupportUi                 bool    `json:"pre_sign_support_ui"`
}

// StorageURI defines model for StorageURI.
type StorageURI struct {
	Location string `json:"location"`
}

// TagCreation defines model for TagCreation.
type TagCreation struct {
	Force *bool `json:"force,omitempty"`

	// ID of tag to create
	Id string `json:"id"`

	// the commit to tag
	Ref string `json:"ref"`
}

// TaskInfo defines model for TaskInfo.
type TaskInfo struct {

	// ID of the task
	Id string `json:"id"`
}

// UnderlyingObjectProperties defines model for UnderlyingObjectProperties.
type UnderlyingObjectProperties struct {
	StorageClass *string `json:"storage_class"`
}

// UploadPart defines model for UploadPart.
type UploadPart struct {
	Etag       string `json:"etag"`
	PartNumber int    `json:"part_number"`
}

// UsageReport defines model for UsageReport.
type UsageReport struct {
	Count int64 `json:"count"`
	Month int   `json:"month"`
	Year  int   `json:"year"`
}

// User defines model for User.
type User struct {

	// Unix Epoch in seconds
	CreationDate int64 `json:"creation_date"`

	// The email address of the user. If API authentication is enabled, this field is mandatory and will be invited to login.
	// If API authentication is disabled, this field will be ignored. All current APIAuthenticators require the email to be
	// lowercase and unique, although custom authenticators may not enforce this.
	Email *string `json:"email,omitempty"`

	// A shorter name for the user than the id. Unlike id it does not identify the user (it
	// might not be unique). Used in some places in the UI.
	FriendlyName *string `json:"friendly_name,omitempty"`

	// A unique identifier for the user. Cannot be edited.
	Id string `json:"id"`
}

// UserCreation defines model for UserCreation.
type UserCreation struct {

	// a unique identifier for the user.
	Id         string `json:"id"`
	InviteUser *bool  `json:"invite_user,omitempty"`
}

// UserList defines model for UserList.
type UserList struct {
	Pagination Pagination `json:"pagination"`
	Results    []User     `json:"results"`
}

// VersionConfig defines model for VersionConfig.
type VersionConfig struct {
	LatestVersion      *string `json:"latest_version,omitempty"`
	UpgradeRecommended *bool   `json:"upgrade_recommended,omitempty"`
	UpgradeUrl         *string `json:"upgrade_url,omitempty"`
	Version            *string `json:"version,omitempty"`
}

// IfNoneMatch defines model for IfNoneMatch.
type IfNoneMatch string

// PaginationAfter defines model for PaginationAfter.
type PaginationAfter string

// PaginationAmount defines model for PaginationAmount.
type PaginationAmount int

// PaginationDelimiter defines model for PaginationDelimiter.
type PaginationDelimiter string

// PaginationPrefix defines model for PaginationPrefix.
type PaginationPrefix string

// BadRequest defines model for BadRequest.
type BadRequest Error

// Conflict defines model for Conflict.
type Conflict Error

// Forbidden defines model for Forbidden.
type Forbidden Error

// NotFound defines model for NotFound.
type NotFound Error

// NotFoundOrNoACL defines model for NotFoundOrNoACL.
type NotFoundOrNoACL ErrorNoACL

// PreconditionFailed defines model for PreconditionFailed.
type PreconditionFailed Error

// ServerError defines model for ServerError.
type ServerError Error

// Unauthorized defines model for Unauthorized.
type Unauthorized Error

// ValidationError defines model for ValidationError.
type ValidationError Error

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody GroupCreation

// SetGroupACLJSONBody defines parameters for SetGroupACL.
type SetGroupACLJSONBody ACL

// ListGroupMembersParams defines parameters for ListGroupMembers.
type ListGroupMembersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListGroupPoliciesParams defines parameters for ListGroupPolicies.
type ListGroupPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// LoginJSONBody defines parameters for Login.
type LoginJSONBody LoginInformation

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreatePolicyJSONBody defines parameters for CreatePolicy.
type CreatePolicyJSONBody Policy

// UpdatePolicyJSONBody defines parameters for UpdatePolicy.
type UpdatePolicyJSONBody Policy

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody UserCreation

// ListUserCredentialsParams defines parameters for ListUserCredentials.
type ListUserCredentialsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// ListUserPoliciesParams defines parameters for ListUserPolicies.
type ListUserPoliciesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// will return all distinct policies attached to the user or any of its groups
	Effective *bool `json:"effective,omitempty"`
}

// ListRepositoriesParams defines parameters for ListRepositories.
type ListRepositoriesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateRepositoryJSONBody defines parameters for CreateRepository.
type CreateRepositoryJSONBody RepositoryCreation

// CreateRepositoryParams defines parameters for CreateRepository.
type CreateRepositoryParams struct {

	// If true, create a bare repository with no initial commit and branch
	Bare *bool `json:"bare,omitempty"`
}

// DeleteRepositoryParams defines parameters for DeleteRepository.
type DeleteRepositoryParams struct {

	// Bypass read-only protection and delete the repository
	Force *bool `json:"force,omitempty"`
}

// ListRepositoryRunsParams defines parameters for ListRepositoryRuns.
type ListRepositoryRunsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
	Branch *string           `json:"branch,omitempty"`
	Commit *string           `json:"commit,omitempty"`
}

// ListRunHooksParams defines parameters for ListRunHooks.
type ListRunHooksParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// InternalDeleteBranchProtectionRuleJSONBody defines parameters for InternalDeleteBranchProtectionRule.
type InternalDeleteBranchProtectionRuleJSONBody struct {
	Pattern string `json:"pattern"`
}

// InternalCreateBranchProtectionRuleJSONBody defines parameters for InternalCreateBranchProtectionRule.
type InternalCreateBranchProtectionRuleJSONBody BranchProtectionRule

// ListBranchesParams defines parameters for ListBranches.
type ListBranchesParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateBranchJSONBody defines parameters for CreateBranch.
type CreateBranchJSONBody BranchCreation

// DeleteBranchParams defines parameters for DeleteBranch.
type DeleteBranchParams struct {
	Force *bool `json:"force,omitempty"`
}

// ResetBranchJSONBody defines parameters for ResetBranch.
type ResetBranchJSONBody ResetCreation

// CherryPickJSONBody defines parameters for CherryPick.
type CherryPickJSONBody CherryPickCreation

// CommitJSONBody defines parameters for Commit.
type CommitJSONBody CommitCreation

// CommitParams defines parameters for Commit.
type CommitParams struct {

	// The source metarange to commit. Branch must not have uncommitted changes.
	SourceMetarange *string `json:"source_metarange,omitempty"`
}

// DiffBranchParams defines parameters for DiffBranch.
type DiffBranchParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
}

// HardResetBranchParams defines parameters for HardResetBranch.
type HardResetBranchParams struct {

	// After reset, branch will point at this reference.
	Ref   string `json:"ref"`
	Force *bool  `json:"force,omitempty"`
}

// ImportCancelParams defines parameters for ImportCancel.
type ImportCancelParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStatusParams defines parameters for ImportStatus.
type ImportStatusParams struct {

	// Unique identifier of the import process
	Id string `json:"id"`
}

// ImportStartJSONBody defines parameters for ImportStart.
type ImportStartJSONBody ImportCreation

// DeleteObjectParams defines parameters for DeleteObject.
type DeleteObjectParams struct {

	// relative to the branch
	Path  string `json:"path"`
	Force *bool  `json:"force,omitempty"`
}

// UploadObjectParams defines parameters for UploadObject.
type UploadObjectParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Deprecated, this capability will not be supported in future releases.
	StorageClass *string `json:"storageClass,omitempty"`
	Force        *bool   `json:"force,omitempty"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`
}

// StageObjectJSONBody defines parameters for StageObject.
type StageObjectJSONBody ObjectStageCreation

// StageObjectParams defines parameters for StageObject.
type StageObjectParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CopyObjectJSONBody defines parameters for CopyObject.
type CopyObjectJSONBody ObjectCopyCreation

// CopyObjectParams defines parameters for CopyObject.
type CopyObjectParams struct {

	// destination path relative to the branch
	DestPath string `json:"dest_path"`
}

// DeleteObjectsJSONBody defines parameters for DeleteObjects.
type DeleteObjectsJSONBody PathList

// DeleteObjectsParams defines parameters for DeleteObjects.
type DeleteObjectsParams struct {
	Force *bool `json:"force,omitempty"`
}

// UploadObjectPreflightParams defines parameters for UploadObjectPreflight.
type UploadObjectPreflightParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// RevertBranchJSONBody defines parameters for RevertBranch.
type RevertBranchJSONBody RevertCreation

// GetPhysicalAddressParams defines parameters for GetPhysicalAddress.
type GetPhysicalAddressParams struct {

	// relative to the branch
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`
}

// LinkPhysicalAddressJSONBody defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressJSONBody StagingMetadata

// LinkPhysicalAddressParams defines parameters for LinkPhysicalAddress.
type LinkPhysicalAddressParams struct {

	// relative to the branch
	Path string `json:"path"`

	// Set to "*" to atomically allow the upload only if the key has no object yet. Other values are not supported.
	IfNoneMatch *IfNoneMatch `json:"If-None-Match,omitempty"`
}

// CreatePresignMultipartUploadParams defines parameters for CreatePresignMultipartUpload.
type CreatePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`

	// number of presigned URL parts required to upload
	Parts *int `json:"parts,omitempty"`
}

// AbortPresignMultipartUploadJSONBody defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadJSONBody AbortPresignMultipartUpload

// AbortPresignMultipartUploadParams defines parameters for AbortPresignMultipartUpload.
type AbortPresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CompletePresignMultipartUploadJSONBody defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadJSONBody CompletePresignMultipartUpload

// CompletePresignMultipartUploadParams defines parameters for CompletePresignMultipartUpload.
type CompletePresignMultipartUploadParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// CreateCommitRecordJSONBody defines parameters for CreateCommitRecord.
type CreateCommitRecordJSONBody CommitRecordCreation

// DumpStatusParams defines parameters for DumpStatus.
type DumpStatusParams struct {
	TaskId string `json:"task_id"`
}

// PrepareGarbageCollectionUncommittedJSONBody defines parameters for PrepareGarbageCollectionUncommitted.
type PrepareGarbageCollectionUncommittedJSONBody PrepareGCUncommittedRequest

// InternalSetGarbageCollectionRulesJSONBody defines parameters for InternalSetGarbageCollectionRules.
type InternalSetGarbageCollectionRulesJSONBody GarbageCollectionRules

// DeleteRepositoryMetadataJSONBody defines parameters for DeleteRepositoryMetadata.
type DeleteRepositoryMetadataJSONBody RepositoryMetadataKeys

// SetRepositoryMetadataJSONBody defines parameters for SetRepositoryMetadata.
type SetRepositoryMetadataJSONBody RepositoryMetadataSet

// RestoreRefsJSONBody defines parameters for RestoreRefs.
type RestoreRefsJSONBody RefsRestore

// CreateSymlinkFileParams defines parameters for CreateSymlinkFile.
type CreateSymlinkFileParams struct {

	// path to the table data
	Location *string `json:"location,omitempty"`
}

// DiffRefsParams defines parameters for DiffRefs.
type DiffRefsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`
	Type      *string              `json:"type,omitempty"`
}

// LogCommitsParams defines parameters for LogCommits.
type LogCommitsParams struct {

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// list of paths, each element is a path of a specific object
	Objects *[]string `json:"objects,omitempty"`

	// list of paths, each element is a path of a prefix
	Prefixes *[]string `json:"prefixes,omitempty"`

	// limit the number of items in return to 'amount'. Without further indication on actual number of items.
	Limit *bool `json:"limit,omitempty"`

	// if set to true, follow only the first parent upon reaching a merge commit
	FirstParent *bool `json:"first_parent,omitempty"`

	// Show commits more recent than a specific date-time. In case used with stop_at parameter, will stop at the first commit that meets any of the conditions.
	Since *time.Time `json:"since,omitempty"`

	// A reference to stop at. In case used with since parameter, will stop at the first commit that meets any of the conditions.
	StopAt *string `json:"stop_at,omitempty"`
}

// GetObjectParams defines parameters for GetObject.
type GetObjectParams struct {

	// relative to the ref
	Path    string `json:"path"`
	Presign *bool  `json:"presign,omitempty"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`
}

// HeadObjectParams defines parameters for HeadObject.
type HeadObjectParams struct {

	// relative to the ref
	Path string `json:"path"`

	// Byte range to retrieve
	Range *string `json:"Range,omitempty"`
}

// ListObjectsParams defines parameters for ListObjects.
type ListObjectsParams struct {
	UserMetadata *bool `json:"user_metadata,omitempty"`
	Presign      *bool `json:"presign,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`

	// delimiter used to group common prefixes by
	Delimiter *PaginationDelimiter `json:"delimiter,omitempty"`

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`
}

// StatObjectParams defines parameters for StatObject.
type StatObjectParams struct {

	// relative to the branch
	Path         string `json:"path"`
	UserMetadata *bool  `json:"user_metadata,omitempty"`
	Presign      *bool  `json:"presign,omitempty"`
}

// GetUnderlyingPropertiesParams defines parameters for GetUnderlyingProperties.
type GetUnderlyingPropertiesParams struct {

	// relative to the branch
	Path string `json:"path"`
}

// MergeIntoBranchJSONBody defines parameters for MergeIntoBranch.
type MergeIntoBranchJSONBody Merge

// RestoreStatusParams defines parameters for RestoreStatus.
type RestoreStatusParams struct {
	TaskId string `json:"task_id"`
}

// RestoreSubmitJSONBody defines parameters for RestoreSubmit.
type RestoreSubmitJSONBody RefsRestore

// SetBranchProtectionRulesJSONBody defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesJSONBody []BranchProtectionRule

// SetBranchProtectionRulesParams defines parameters for SetBranchProtectionRules.
type SetBranchProtectionRulesParams struct {

	// if provided, the branch protection rules will be updated only if the current ETag match the provided value
	IfMatch *string `json:"If-Match,omitempty"`
}

// SetGCRulesJSONBody defines parameters for SetGCRules.
type SetGCRulesJSONBody GarbageCollectionRules

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {

	// return items prefixed with this value
	Prefix *PaginationPrefix `json:"prefix,omitempty"`

	// return items after this value
	After *PaginationAfter `json:"after,omitempty"`

	// how many items to return
	Amount *PaginationAmount `json:"amount,omitempty"`
}

// CreateTagJSONBody defines parameters for CreateTag.
type CreateTagJSONBody TagCreation

// DeleteTagParams defines parameters for DeleteTag.
type DeleteTagParams struct {
	Force *bool `json:"force,omitempty"`
}

// SetupCommPrefsJSONBody defines parameters for SetupCommPrefs.
type SetupCommPrefsJSONBody CommPrefsInput

// SetupJSONBody defines parameters for Setup.
type SetupJSONBody Setup

// PostStatsEventsJSONBody defines parameters for PostStatsEvents.
type PostStatsEventsJSONBody StatsEventsList

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// SetGroupACLJSONRequestBody defines body for SetGroupACL for application/json ContentType.
type SetGroupACLJSONRequestBody SetGroupACLJSONBody

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// CreatePolicyJSONRequestBody defines body for CreatePolicy for application/json ContentType.
type CreatePolicyJSONRequestBody CreatePolicyJSONBody

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody UpdatePolicyJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// CreateRepositoryJSONRequestBody defines body for CreateRepository for application/json ContentType.
type CreateRepositoryJSONRequestBody CreateRepositoryJSONBody

// InternalDeleteBranchProtectionRuleJSONRequestBody defines body for InternalDeleteBranchProtectionRule for application/json ContentType.
type InternalDeleteBranchProtectionRuleJSONRequestBody InternalDeleteBranchProtectionRuleJSONBody

// InternalCreateBranchProtectionRuleJSONRequestBody defines body for InternalCreateBranchProtectionRule for application/json ContentType.
type InternalCreateBranchProtectionRuleJSONRequestBody InternalCreateBranchProtectionRuleJSONBody

// CreateBranchJSONRequestBody defines body for CreateBranch for application/json ContentType.
type CreateBranchJSONRequestBody CreateBranchJSONBody

// ResetBranchJSONRequestBody defines body for ResetBranch for application/json ContentType.
type ResetBranchJSONRequestBody ResetBranchJSONBody

// CherryPickJSONRequestBody defines body for CherryPick for application/json ContentType.
type CherryPickJSONRequestBody CherryPickJSONBody

// CommitJSONRequestBody defines body for Commit for application/json ContentType.
type CommitJSONRequestBody CommitJSONBody

// ImportStartJSONRequestBody defines body for ImportStart for application/json ContentType.
type ImportStartJSONRequestBody ImportStartJSONBody

// StageObjectJSONRequestBody defines body for StageObject for application/json ContentType.
type StageObjectJSONRequestBody StageObjectJSONBody

// CopyObjectJSONRequestBody defines body for CopyObject for application/json ContentType.
type CopyObjectJSONRequestBody CopyObjectJSONBody

// DeleteObjectsJSONRequestBody defines body for DeleteObjects for application/json ContentType.
type DeleteObjectsJSONRequestBody DeleteObjectsJSONBody

// RevertBranchJSONRequestBody defines body for RevertBranch for application/json ContentType.
type RevertBranchJSONRequestBody RevertBranchJSONBody

// LinkPhysicalAddressJSONRequestBody defines body for LinkPhysicalAddress for application/json ContentType.
type LinkPhysicalAddressJSONRequestBody LinkPhysicalAddressJSONBody

// AbortPresignMultipartUploadJSONRequestBody defines body for AbortPresignMultipartUpload for application/json ContentType.
type AbortPresignMultipartUploadJSONRequestBody AbortPresignMultipartUploadJSONBody

// CompletePresignMultipartUploadJSONRequestBody defines body for CompletePresignMultipartUpload for application/json ContentType.
type CompletePresignMultipartUploadJSONRequestBody CompletePresignMultipartUploadJSONBody

// CreateCommitRecordJSONRequestBody defines body for CreateCommitRecord for application/json ContentType.
type CreateCommitRecordJSONRequestBody CreateCommitRecordJSONBody

// PrepareGarbageCollectionUncommittedJSONRequestBody defines body for PrepareGarbageCollectionUncommitted for application/json ContentType.
type PrepareGarbageCollectionUncommittedJSONRequestBody PrepareGarbageCollectionUncommittedJSONBody

// InternalSetGarbageCollectionRulesJSONRequestBody defines body for InternalSetGarbageCollectionRules for application/json ContentType.
type InternalSetGarbageCollectionRulesJSONRequestBody InternalSetGarbageCollectionRulesJSONBody

// DeleteRepositoryMetadataJSONRequestBody defines body for DeleteRepositoryMetadata for application/json ContentType.
type DeleteRepositoryMetadataJSONRequestBody DeleteRepositoryMetadataJSONBody

// SetRepositoryMetadataJSONRequestBody defines body for SetRepositoryMetadata for application/json ContentType.
type SetRepositoryMetadataJSONRequestBody SetRepositoryMetadataJSONBody

// RestoreRefsJSONRequestBody defines body for RestoreRefs for application/json ContentType.
type RestoreRefsJSONRequestBody RestoreRefsJSONBody

// MergeIntoBranchJSONRequestBody defines body for MergeIntoBranch for application/json ContentType.
type MergeIntoBranchJSONRequestBody MergeIntoBranchJSONBody

// RestoreSubmitJSONRequestBody defines body for RestoreSubmit for application/json ContentType.
type RestoreSubmitJSONRequestBody RestoreSubmitJSONBody

// SetBranchProtectionRulesJSONRequestBody defines body for SetBranchProtectionRules for application/json ContentType.
type SetBranchProtectionRulesJSONRequestBody SetBranchProtectionRulesJSONBody

// SetGCRulesJSONRequestBody defines body for SetGCRules for application/json ContentType.
type SetGCRulesJSONRequestBody SetGCRulesJSONBody

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody CreateTagJSONBody

// SetupCommPrefsJSONRequestBody defines body for SetupCommPrefs for application/json ContentType.
type SetupCommPrefsJSONRequestBody SetupCommPrefsJSONBody

// SetupJSONRequestBody defines body for Setup for application/json ContentType.
type SetupJSONRequestBody SetupJSONBody

// PostStatsEventsJSONRequestBody defines body for PostStatsEvents for application/json ContentType.
type PostStatsEventsJSONRequestBody PostStatsEventsJSONBody

// Getter for additional properties for Commit_Metadata. Returns the specified
// element and whether it was found
func (a Commit_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Commit_Metadata
func (a *Commit_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a *Commit_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Commit_Metadata to handle AdditionalProperties
func (a Commit_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitCreation_Metadata
func (a *CommitCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a *CommitCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitCreation_Metadata to handle AdditionalProperties
func (a CommitCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CommitRecordCreation_Metadata. Returns the specified
// element and whether it was found
func (a CommitRecordCreation_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CommitRecordCreation_Metadata
func (a *CommitRecordCreation_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a *CommitRecordCreation_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CommitRecordCreation_Metadata to handle AdditionalProperties
func (a CommitRecordCreation_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CompletePresignMultipartUpload_UserMetadata. Returns the specified
// element and whether it was found
func (a CompletePresignMultipartUpload_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CompletePresignMultipartUpload_UserMetadata
func (a *CompletePresignMultipartUpload_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a *CompletePresignMultipartUpload_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CompletePresignMultipartUpload_UserMetadata to handle AdditionalProperties
func (a CompletePresignMultipartUpload_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Merge_Metadata. Returns the specified
// element and whether it was found
func (a Merge_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Merge_Metadata
func (a *Merge_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a *Merge_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Merge_Metadata to handle AdditionalProperties
func (a Merge_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ObjectUserMetadata. Returns the specified
// element and whether it was found
func (a ObjectUserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ObjectUserMetadata
func (a *ObjectUserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a *ObjectUserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ObjectUserMetadata to handle AdditionalProperties
func (a ObjectUserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadata
func (a *RepositoryMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a *RepositoryMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadata to handle AdditionalProperties
func (a RepositoryMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RepositoryMetadataSet_Metadata. Returns the specified
// element and whether it was found
func (a RepositoryMetadataSet_Metadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RepositoryMetadataSet_Metadata
func (a *RepositoryMetadataSet_Metadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a *RepositoryMetadataSet_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RepositoryMetadataSet_Metadata to handle AdditionalProperties
func (a RepositoryMetadataSet_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for StagingMetadata_UserMetadata. Returns the specified
// element and whether it was found
func (a StagingMetadata_UserMetadata) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for StagingMetadata_UserMetadata
func (a *StagingMetadata_UserMetadata) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a *StagingMetadata_UserMetadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for StagingMetadata_UserMetadata to handle AdditionalProperties
func (a StagingMetadata_UserMetadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroup request  with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupACL request
	GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupMembers request
	ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupMembership request
	DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGroupMembership request
	AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupPolicies request
	ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Login request  with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUser request  with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserCredentials request
	ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCredentials request
	CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCredentials request
	DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredentials request
	GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserGroups request
	ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserPolicies request
	ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPolicyToUser request
	AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageConfig request
	GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLakeFSVersion request
	GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositories request
	ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepository request
	DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepository request
	GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRepositoryRuns request
	ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRun request
	GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRunHooks request
	ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunHookOutput request
	GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBranches request
	ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBranch request  with any body
	CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBranch request
	DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranch request
	GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetBranch request  with any body
	ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CherryPick request  with any body
	CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Commit request  with any body
	CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffBranch request
	DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HardResetBranch request
	HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportCancel request
	ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStatus request
	ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportStart request  with any body
	ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObject request
	DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObject request  with any body
	UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StageObject request  with any body
	StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyObject request  with any body
	CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadObjectPreflight request
	UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevertBranch request  with any body
	RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPhysicalAddress request
	GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommit request
	GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpStatus request
	DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpSubmit request
	DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetaRange request
	GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRange request
	GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DumpRefs request
	DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSymlinkFile request
	CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DiffRefs request
	DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogCommits request
	LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetObject request
	GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadObject request
	HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListObjects request
	ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatObject request
	StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnderlyingProperties request
	GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindMergeBase request
	FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreStatus request
	RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGCRules request
	DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGCRules request
	GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetGCRules request  with any body
	SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTags request
	ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTag request  with any body
	CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTag request
	DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTag request
	GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSetupState request
	GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Setup request  with any body
	SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageReportSummary request
	GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentUser request
	GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAuthCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupACL(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupACLRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACLWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGroupACL(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGroupACLRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupMembers(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupMembersRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddGroupMembership(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupMembershipRequest(c.Server, groupId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupPolicies(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupPoliciesRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToGroup(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToGroupRequest(c.Server, groupId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePolicy(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserCredentials(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserCredentialsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCredentials(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCredentialsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredentials(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCredentialsRequest(c.Server, userId, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserGroups(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserGroupsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserPolicies(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserPoliciesRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachPolicyFromUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachPolicyFromUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPolicyToUser(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPolicyToUserRequest(c.Server, userId, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGarbageCollectionConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGarbageCollectionConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLakeFSVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLakeFSVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositories(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepositoryWithBody(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRepository(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRepositoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepository(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepository(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRepositoryRuns(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRepositoryRunsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRun(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunRequest(c.Server, repository, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRunHooks(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRunHooksRequest(c.Server, repository, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunHookOutput(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunHookOutputRequest(c.Server, repository, runId, hookRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteBranchProtectionRule(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRuleWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalCreateBranchProtectionRule(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalCreateBranchProtectionRuleRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchProtectionRulePreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchProtectionRulePreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBranches(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBranchesRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranchWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBranch(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBranchRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBranch(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranch(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchRequest(c.Server, repository, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetBranch(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPickWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CherryPick(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCherryPickRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitWithBody(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Commit(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffBranch(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HardResetBranch(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHardResetBranchRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportCancel(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportCancelRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStatus(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStatusRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStartWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportStart(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportStartRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObject(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectWithBody(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObjectWithBody(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StageObject(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStageObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObjectWithBody(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyObject(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyObjectRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjectsWithBody(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteObjects(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteObjectsRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadObjectPreflight(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadObjectPreflightRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranchWithBody(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequestWithBody(c.Server, repository, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertBranch(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertBranchRequest(c.Server, repository, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPhysicalAddress(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPhysicalAddressRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddressWithBody(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequestWithBody(c.Server, repository, branch, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LinkPhysicalAddress(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLinkPhysicalAddressRequest(c.Server, repository, branch, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePresignMultipartUpload(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePresignMultipartUploadRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortPresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortPresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUploadWithBody(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequestWithBody(c.Server, repository, branch, uploadId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompletePresignMultipartUpload(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompletePresignMultipartUploadRequest(c.Server, repository, branch, uploadId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecordWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCommitRecord(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCommitRecordRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommit(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommitRequest(c.Server, repository, commitId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpStatus(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpSubmit(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpSubmitRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionCommits(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionCommitsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommittedWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrepareGarbageCollectionUncommitted(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrepareGarbageCollectionUncommittedRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalDeleteGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalDeleteGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalGetGarbageCollectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalGetGarbageCollectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InternalSetGarbageCollectionRules(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInternalSetGarbageCollectionRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGarbageCollectionRulesPreflight(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGarbageCollectionRulesPreflightRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepositoryMetadata(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRepositoryMetadata(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRepositoryMetadataRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadataWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetRepositoryMetadata(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetRepositoryMetadataRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetaRange(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetaRangeRequest(c.Server, repository, metaRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRange(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRangeRequest(c.Server, repository, pRange)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DumpRefs(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDumpRefsRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefsWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreRefs(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreRefsRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSymlinkFile(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSymlinkFileRequest(c.Server, repository, branch, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DiffRefs(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDiffRefsRequest(c.Server, repository, leftRef, rightRef, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogCommits(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogCommitsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetObject(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadObject(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListObjects(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListObjectsRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatObject(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatObjectRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnderlyingProperties(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnderlyingPropertiesRequest(c.Server, repository, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindMergeBase(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindMergeBaseRequest(c.Server, repository, sourceRef, destinationBranch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranchWithBody(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequestWithBody(c.Server, repository, sourceRef, destinationBranch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIntoBranch(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIntoBranchRequest(c.Server, repository, sourceRef, destinationBranch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreStatus(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreStatusRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmitWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestoreSubmit(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestoreSubmitRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBranchProtectionRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBranchProtectionRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRulesWithBody(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequestWithBody(c.Server, repository, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBranchProtectionRules(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBranchProtectionRulesRequest(c.Server, repository, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGCRules(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGCRulesRequest(c.Server, repository)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRulesWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetGCRules(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetGCRulesRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTags(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTagsRequest(c.Server, repository, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTagWithBody(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequestWithBody(c.Server, repository, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTag(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTagRequest(c.Server, repository, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTag(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagRequest(c.Server, repository, tag, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTag(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagRequest(c.Server, repository, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupCommPrefs(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupCommPrefsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSetupState(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSetupStateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Setup(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEventsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostStatsEvents(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostStatsEventsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageReportSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageReportSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAuthCapabilitiesRequest generates requests for GetAuthCapabilities
func NewGetAuthCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/capabilities")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupACLRequest generates requests for GetGroupACL
func NewGetGroupACLRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGroupACLRequest calls the generic SetGroupACL builder with application/json body
func NewSetGroupACLRequest(server string, groupId string, body SetGroupACLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGroupACLRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewSetGroupACLRequestWithBody generates requests for SetGroupACL with any type of body
func NewSetGroupACLRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/acl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupMembersRequest generates requests for ListGroupMembers
func NewListGroupMembersRequest(server string, groupId string, params *ListGroupMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGroupMembershipRequest generates requests for DeleteGroupMembership
func NewDeleteGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGroupMembershipRequest generates requests for AddGroupMembership
func NewAddGroupMembershipRequest(server string, groupId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListGroupPoliciesRequest generates requests for ListGroupPolicies
func NewListGroupPoliciesRequest(server string, groupId string, params *ListGroupPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromGroupRequest generates requests for DetachPolicyFromGroup
func NewDetachPolicyFromGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToGroupRequest generates requests for AttachPolicyToGroup
func NewAttachPolicyToGroupRequest(server string, groupId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/groups/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePolicyRequest calls the generic CreatePolicy builder with application/json body
func NewCreatePolicyRequest(server string, body CreatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePolicyRequestWithBody generates requests for CreatePolicy with any type of body
func NewCreatePolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policyId string, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserCredentialsRequest generates requests for ListUserCredentials
func NewListUserCredentialsRequest(server string, userId string, params *ListUserCredentialsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCredentialsRequest generates requests for CreateCredentials
func NewCreateCredentialsRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCredentialsRequest generates requests for DeleteCredentials
func NewDeleteCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCredentialsRequest generates requests for GetCredentials
func NewGetCredentialsRequest(server string, userId string, accessKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/credentials/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserGroupsRequest generates requests for ListUserGroups
func NewListUserGroupsRequest(server string, userId string, params *ListUserGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserPoliciesRequest generates requests for ListUserPolicies
func NewListUserPoliciesRequest(server string, userId string, params *ListUserPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDetachPolicyFromUserRequest generates requests for DetachPolicyFromUser
func NewDetachPolicyFromUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPolicyToUserRequest generates requests for AttachPolicyToUser
func NewAttachPolicyToUserRequest(server string, userId string, policyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/users/%s/policies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGarbageCollectionConfigRequest generates requests for GetGarbageCollectionConfig
func NewGetGarbageCollectionConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/garbage-collection")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageConfigRequest generates requests for GetStorageConfig
func NewGetStorageConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/storage")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLakeFSVersionRequest generates requests for GetLakeFSVersion
func NewGetLakeFSVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config/version")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/healthcheck")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoriesRequest generates requests for ListRepositories
func NewListRepositoriesRequest(server string, params *ListRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRepositoryRequest calls the generic CreateRepository builder with application/json body
func NewCreateRepositoryRequest(server string, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRepositoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRepositoryRequestWithBody generates requests for CreateRepository with any type of body
func NewCreateRepositoryRequestWithBody(server string, params *CreateRepositoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Bare != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bare", runtime.ParamLocationQuery, *params.Bare); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRepositoryRequest generates requests for DeleteRepository
func NewDeleteRepositoryRequest(server string, repository string, params *DeleteRepositoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRepositoryRequest generates requests for GetRepository
func NewGetRepositoryRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRepositoryRunsRequest generates requests for ListRepositoryRuns
func NewListRepositoryRunsRequest(server string, repository string, params *ListRepositoryRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Commit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "commit", runtime.ParamLocationQuery, *params.Commit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunRequest generates requests for GetRun
func NewGetRunRequest(server string, repository string, runId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRunHooksRequest generates requests for ListRunHooks
func NewListRunHooksRequest(server string, repository string, runId string, params *ListRunHooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunHookOutputRequest generates requests for GetRunHookOutput
func NewGetRunHookOutputRequest(server string, repository string, runId string, hookRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_run_id", runtime.ParamLocationPath, hookRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/actions/runs/%s/hooks/%s/output", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalDeleteBranchProtectionRuleRequest calls the generic InternalDeleteBranchProtectionRule builder with application/json body
func NewInternalDeleteBranchProtectionRuleRequest(server string, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalDeleteBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalDeleteBranchProtectionRuleRequestWithBody generates requests for InternalDeleteBranchProtectionRule with any type of body
func NewInternalDeleteBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalGetBranchProtectionRulesRequest generates requests for InternalGetBranchProtectionRules
func NewInternalGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalCreateBranchProtectionRuleRequest calls the generic InternalCreateBranchProtectionRule builder with application/json body
func NewInternalCreateBranchProtectionRuleRequest(server string, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalCreateBranchProtectionRuleRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalCreateBranchProtectionRuleRequestWithBody generates requests for InternalCreateBranchProtectionRule with any type of body
func NewInternalCreateBranchProtectionRuleRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBranchProtectionRulePreflightRequest generates requests for CreateBranchProtectionRulePreflight
func NewCreateBranchProtectionRulePreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branch_protection/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBranchesRequest generates requests for ListBranches
func NewListBranchesRequest(server string, repository string, params *ListBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBranchRequest calls the generic CreateBranch builder with application/json body
func NewCreateBranchRequest(server string, repository string, body CreateBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBranchRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateBranchRequestWithBody generates requests for CreateBranch with any type of body
func NewCreateBranchRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBranchRequest generates requests for DeleteBranch
func NewDeleteBranchRequest(server string, repository string, branch string, params *DeleteBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBranchRequest generates requests for GetBranch
func NewGetBranchRequest(server string, repository string, branch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetBranchRequest calls the generic ResetBranch builder with application/json body
func NewResetBranchRequest(server string, repository string, branch string, body ResetBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewResetBranchRequestWithBody generates requests for ResetBranch with any type of body
func NewResetBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCherryPickRequest calls the generic CherryPick builder with application/json body
func NewCherryPickRequest(server string, repository string, branch string, body CherryPickJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCherryPickRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewCherryPickRequestWithBody generates requests for CherryPick with any type of body
func NewCherryPickRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/cherry-pick", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCommitRequest calls the generic Commit builder with application/json body
func NewCommitRequest(server string, repository string, branch string, params *CommitParams, body CommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCommitRequestWithBody generates requests for Commit with any type of body
func NewCommitRequestWithBody(server string, repository string, branch string, params *CommitParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.SourceMetarange != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_metarange", runtime.ParamLocationQuery, *params.SourceMetarange); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDiffBranchRequest generates requests for DiffBranch
func NewDiffBranchRequest(server string, repository string, branch string, params *DiffBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/diff", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHardResetBranchRequest generates requests for HardResetBranch
func NewHardResetBranchRequest(server string, repository string, branch string, params *HardResetBranchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/hard_reset", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, params.Ref); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportCancelRequest generates requests for ImportCancel
func NewImportCancelRequest(server string, repository string, branch string, params *ImportCancelParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStatusRequest generates requests for ImportStatus
func NewImportStatusRequest(server string, repository string, branch string, params *ImportStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportStartRequest calls the generic ImportStart builder with application/json body
func NewImportStartRequest(server string, repository string, branch string, body ImportStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportStartRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewImportStartRequestWithBody generates requests for ImportStart with any type of body
func NewImportStartRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectRequest generates requests for DeleteObject
func NewDeleteObjectRequest(server string, repository string, branch string, params *DeleteObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadObjectRequestWithBody generates requests for UploadObject with any type of body
func NewUploadObjectRequestWithBody(server string, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.StorageClass != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageClass", runtime.ParamLocationQuery, *params.StorageClass); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	return req, nil
}

// NewStageObjectRequest calls the generic StageObject builder with application/json body
func NewStageObjectRequest(server string, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStageObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewStageObjectRequestWithBody generates requests for StageObject with any type of body
func NewStageObjectRequestWithBody(server string, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyObjectRequest calls the generic CopyObject builder with application/json body
func NewCopyObjectRequest(server string, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyObjectRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewCopyObjectRequestWithBody generates requests for CopyObject with any type of body
func NewCopyObjectRequestWithBody(server string, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/copy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dest_path", runtime.ParamLocationQuery, params.DestPath); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteObjectsRequest calls the generic DeleteObjects builder with application/json body
func NewDeleteObjectsRequest(server string, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteObjectsRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewDeleteObjectsRequestWithBody generates requests for DeleteObjects with any type of body
func NewDeleteObjectsRequestWithBody(server string, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadObjectPreflightRequest generates requests for UploadObjectPreflight
func NewUploadObjectPreflightRequest(server string, repository string, branch string, params *UploadObjectPreflightParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/objects/stage_allowed", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRevertBranchRequest calls the generic RevertBranch builder with application/json body
func NewRevertBranchRequest(server string, repository string, branch string, body RevertBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevertBranchRequestWithBody(server, repository, branch, "application/json", bodyReader)
}

// NewRevertBranchRequestWithBody generates requests for RevertBranch with any type of body
func NewRevertBranchRequestWithBody(server string, repository string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/revert", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPhysicalAddressRequest generates requests for GetPhysicalAddress
func NewGetPhysicalAddressRequest(server string, repository string, branch string, params *GetPhysicalAddressParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLinkPhysicalAddressRequest calls the generic LinkPhysicalAddress builder with application/json body
func NewLinkPhysicalAddressRequest(server string, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLinkPhysicalAddressRequestWithBody(server, repository, branch, params, "application/json", bodyReader)
}

// NewLinkPhysicalAddressRequestWithBody generates requests for LinkPhysicalAddress with any type of body
func NewLinkPhysicalAddressRequestWithBody(server string, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/backing", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfNoneMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam0)
	}

	return req, nil
}

// NewCreatePresignMultipartUploadRequest generates requests for CreatePresignMultipartUpload
func NewCreatePresignMultipartUploadRequest(server string, repository string, branch string, params *CreatePresignMultipartUploadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Parts != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parts", runtime.ParamLocationQuery, *params.Parts); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAbortPresignMultipartUploadRequest calls the generic AbortPresignMultipartUpload builder with application/json body
func NewAbortPresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAbortPresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewAbortPresignMultipartUploadRequestWithBody generates requests for AbortPresignMultipartUpload with any type of body
func NewAbortPresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCompletePresignMultipartUploadRequest calls the generic CompletePresignMultipartUpload builder with application/json body
func NewCompletePresignMultipartUploadRequest(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompletePresignMultipartUploadRequestWithBody(server, repository, branch, uploadId, params, "application/json", bodyReader)
}

// NewCompletePresignMultipartUploadRequestWithBody generates requests for CompletePresignMultipartUpload with any type of body
func NewCompletePresignMultipartUploadRequestWithBody(server string, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "uploadId", runtime.ParamLocationPath, uploadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/branches/%s/staging/pmpu/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCommitRecordRequest calls the generic CreateCommitRecord builder with application/json body
func NewCreateCommitRecordRequest(server string, repository string, body CreateCommitRecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCommitRecordRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateCommitRecordRequestWithBody generates requests for CreateCommitRecord with any type of body
func NewCreateCommitRecordRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCommitRequest generates requests for GetCommit
func NewGetCommitRequest(server string, repository string, commitId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "commitId", runtime.ParamLocationPath, commitId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/commits/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpStatusRequest generates requests for DumpStatus
func NewDumpStatusRequest(server string, repository string, params *DumpStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpSubmitRequest generates requests for DumpSubmit
func NewDumpSubmitRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionCommitsRequest generates requests for PrepareGarbageCollectionCommits
func NewPrepareGarbageCollectionCommitsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPrepareGarbageCollectionUncommittedRequest calls the generic PrepareGarbageCollectionUncommitted builder with application/json body
func NewPrepareGarbageCollectionUncommittedRequest(server string, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrepareGarbageCollectionUncommittedRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewPrepareGarbageCollectionUncommittedRequestWithBody generates requests for PrepareGarbageCollectionUncommitted with any type of body
func NewPrepareGarbageCollectionUncommittedRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/prepare_uncommited", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInternalDeleteGarbageCollectionRulesRequest generates requests for InternalDeleteGarbageCollectionRules
func NewInternalDeleteGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalGetGarbageCollectionRulesRequest generates requests for InternalGetGarbageCollectionRules
func NewInternalGetGarbageCollectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInternalSetGarbageCollectionRulesRequest calls the generic InternalSetGarbageCollectionRules builder with application/json body
func NewInternalSetGarbageCollectionRulesRequest(server string, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInternalSetGarbageCollectionRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewInternalSetGarbageCollectionRulesRequestWithBody generates requests for InternalSetGarbageCollectionRules with any type of body
func NewInternalSetGarbageCollectionRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetGarbageCollectionRulesPreflightRequest generates requests for SetGarbageCollectionRulesPreflight
func NewSetGarbageCollectionRulesPreflightRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/gc/rules/set_allowed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRepositoryMetadataRequest calls the generic DeleteRepositoryMetadata builder with application/json body
func NewDeleteRepositoryMetadataRequest(server string, repository string, body DeleteRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewDeleteRepositoryMetadataRequestWithBody generates requests for DeleteRepositoryMetadata with any type of body
func NewDeleteRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRepositoryMetadataRequest generates requests for GetRepositoryMetadata
func NewGetRepositoryMetadataRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetRepositoryMetadataRequest calls the generic SetRepositoryMetadata builder with application/json body
func NewSetRepositoryMetadataRequest(server string, repository string, body SetRepositoryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetRepositoryMetadataRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetRepositoryMetadataRequestWithBody generates requests for SetRepositoryMetadata with any type of body
func NewSetRepositoryMetadataRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetaRangeRequest generates requests for GetMetaRange
func NewGetMetaRangeRequest(server string, repository string, metaRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "meta_range", runtime.ParamLocationPath, metaRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/meta_range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRangeRequest generates requests for GetRange
func NewGetRangeRequest(server string, repository string, pRange string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "range", runtime.ParamLocationPath, pRange)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/metadata/range/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDumpRefsRequest generates requests for DumpRefs
func NewDumpRefsRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/dump", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreRefsRequest calls the generic RestoreRefs builder with application/json body
func NewRestoreRefsRequest(server string, repository string, body RestoreRefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreRefsRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreRefsRequestWithBody generates requests for RestoreRefs with any type of body
func NewRestoreRefsRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSymlinkFileRequest generates requests for CreateSymlinkFile
func NewCreateSymlinkFileRequest(server string, repository string, branch string, params *CreateSymlinkFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/symlink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Location != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDiffRefsRequest generates requests for DiffRefs
func NewDiffRefsRequest(server string, repository string, leftRef string, rightRef string, params *DiffRefsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "leftRef", runtime.ParamLocationPath, leftRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rightRef", runtime.ParamLocationPath, rightRef)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/diff/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogCommitsRequest generates requests for LogCommits
func NewLogCommitsRequest(server string, repository string, ref string, params *LogCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Objects != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objects", runtime.ParamLocationQuery, *params.Objects); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefixes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefixes", runtime.ParamLocationQuery, *params.Prefixes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FirstParent != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first_parent", runtime.ParamLocationQuery, *params.FirstParent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StopAt != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stop_at", runtime.ParamLocationQuery, *params.StopAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetObjectRequest generates requests for GetObject
func NewGetObjectRequest(server string, repository string, ref string, params *GetObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	return req, nil
}

// NewHeadObjectRequest generates requests for HeadObject
func NewHeadObjectRequest(server string, repository string, ref string, params *HeadObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.Range != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Range", runtime.ParamLocationHeader, *params.Range)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Range", headerParam0)
	}

	return req, nil
}

// NewListObjectsRequest generates requests for ListObjects
func NewListObjectsRequest(server string, repository string, ref string, params *ListObjectsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/ls", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Delimiter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delimiter", runtime.ParamLocationQuery, *params.Delimiter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatObjectRequest generates requests for StatObject
func NewStatObjectRequest(server string, repository string, ref string, params *StatObjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/stat", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.UserMetadata != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_metadata", runtime.ParamLocationQuery, *params.UserMetadata); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Presign != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "presign", runtime.ParamLocationQuery, *params.Presign); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnderlyingPropertiesRequest generates requests for GetUnderlyingProperties
func NewGetUnderlyingPropertiesRequest(server string, repository string, ref string, params *GetUnderlyingPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/objects/underlyingProperties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindMergeBaseRequest generates requests for FindMergeBase
func NewFindMergeBaseRequest(server string, repository string, sourceRef string, destinationBranch string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeIntoBranchRequest calls the generic MergeIntoBranch builder with application/json body
func NewMergeIntoBranchRequest(server string, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeIntoBranchRequestWithBody(server, repository, sourceRef, destinationBranch, "application/json", bodyReader)
}

// NewMergeIntoBranchRequestWithBody generates requests for MergeIntoBranch with any type of body
func NewMergeIntoBranchRequestWithBody(server string, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sourceRef", runtime.ParamLocationPath, sourceRef)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "destinationBranch", runtime.ParamLocationPath, destinationBranch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/refs/%s/merge/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRestoreStatusRequest generates requests for RestoreStatus
func NewRestoreStatusRequest(server string, repository string, params *RestoreStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task_id", runtime.ParamLocationQuery, params.TaskId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestoreSubmitRequest calls the generic RestoreSubmit builder with application/json body
func NewRestoreSubmitRequest(server string, repository string, body RestoreSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRestoreSubmitRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewRestoreSubmitRequestWithBody generates requests for RestoreSubmit with any type of body
func NewRestoreSubmitRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/restore", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBranchProtectionRulesRequest generates requests for GetBranchProtectionRules
func NewGetBranchProtectionRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBranchProtectionRulesRequest calls the generic SetBranchProtectionRules builder with application/json body
func NewSetBranchProtectionRulesRequest(server string, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBranchProtectionRulesRequestWithBody(server, repository, params, "application/json", bodyReader)
}

// NewSetBranchProtectionRulesRequestWithBody generates requests for SetBranchProtectionRules with any type of body
func NewSetBranchProtectionRulesRequestWithBody(server string, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/branch_protection", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// NewDeleteGCRulesRequest generates requests for DeleteGCRules
func NewDeleteGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGCRulesRequest generates requests for GetGCRules
func NewGetGCRulesRequest(server string, repository string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetGCRulesRequest calls the generic SetGCRules builder with application/json body
func NewSetGCRulesRequest(server string, repository string, body SetGCRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetGCRulesRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewSetGCRulesRequestWithBody generates requests for SetGCRules with any type of body
func NewSetGCRulesRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/settings/gc_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTagsRequest generates requests for ListTags
func NewListTagsRequest(server string, repository string, params *ListTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Prefix != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Amount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "amount", runtime.ParamLocationQuery, *params.Amount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTagRequest calls the generic CreateTag builder with application/json body
func NewCreateTagRequest(server string, repository string, body CreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTagRequestWithBody(server, repository, "application/json", bodyReader)
}

// NewCreateTagRequestWithBody generates requests for CreateTag with any type of body
func NewCreateTagRequestWithBody(server string, repository string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagRequest generates requests for DeleteTag
func NewDeleteTagRequest(server string, repository string, tag string, params *DeleteTagParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Force != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagRequest generates requests for GetTag
func NewGetTagRequest(server string, repository string, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository", runtime.ParamLocationPath, repository)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/tags/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupCommPrefsRequest calls the generic SetupCommPrefs builder with application/json body
func NewSetupCommPrefsRequest(server string, body SetupCommPrefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupCommPrefsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupCommPrefsRequestWithBody generates requests for SetupCommPrefs with any type of body
func NewSetupCommPrefsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_comm_prefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSetupStateRequest generates requests for GetSetupState
func NewGetSetupStateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetupRequest calls the generic Setup builder with application/json body
func NewSetupRequest(server string, body SetupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetupRequestWithBody(server, "application/json", bodyReader)
}

// NewSetupRequestWithBody generates requests for Setup with any type of body
func NewSetupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/setup_lakefs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostStatsEventsRequest calls the generic PostStatsEvents builder with application/json body
func NewPostStatsEventsRequest(server string, body PostStatsEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostStatsEventsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostStatsEventsRequestWithBody generates requests for PostStatsEvents with any type of body
func NewPostStatsEventsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsageReportSummaryRequest generates requests for GetUsageReportSummary
func NewGetUsageReportSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage-report/summary")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentUserRequest generates requests for GetCurrentUser
func NewGetCurrentUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAuthCapabilities request
	GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error)

	// ListGroups request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroup request  with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroup request
	DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroup request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// GetGroupACL request
	GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error)

	// SetGroupACL request  with any body
	SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error)

	// ListGroupMembers request
	ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error)

	// DeleteGroupMembership request
	DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error)

	// AddGroupMembership request
	AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error)

	// ListGroupPolicies request
	ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error)

	// DetachPolicyFromGroup request
	DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error)

	// AttachPolicyToGroup request
	AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error)

	// Login request  with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// ListPolicies request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// CreatePolicy request  with any body
	CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error)

	// DeletePolicy request
	DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicy request
	GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicy request  with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	// ListUsers request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUser request  with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListUserCredentials request
	ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error)

	// CreateCredentials request
	CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error)

	// DeleteCredentials request
	DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error)

	// GetCredentials request
	GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error)

	// ListUserGroups request
	ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error)

	// ListUserPolicies request
	ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error)

	// DetachPolicyFromUser request
	DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error)

	// AttachPolicyToUser request
	AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetGarbageCollectionConfig request
	GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error)

	// GetStorageConfig request
	GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error)

	// GetLakeFSVersion request
	GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error)

	// HealthCheck request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// ListRepositories request
	ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error)

	// CreateRepository request  with any body
	CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error)

	// DeleteRepository request
	DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error)

	// GetRepository request
	GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error)

	// ListRepositoryRuns request
	ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error)

	// GetRun request
	GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error)

	// ListRunHooks request
	ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error)

	// GetRunHookOutput request
	GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error)

	// InternalDeleteBranchProtectionRule request  with any body
	InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error)

	// InternalGetBranchProtectionRules request
	InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error)

	// InternalCreateBranchProtectionRule request  with any body
	InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error)

	// CreateBranchProtectionRulePreflight request
	CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error)

	// ListBranches request
	ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error)

	// CreateBranch request  with any body
	CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error)

	// DeleteBranch request
	DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error)

	// GetBranch request
	GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error)

	// ResetBranch request  with any body
	ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error)

	// CherryPick request  with any body
	CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error)

	// Commit request  with any body
	CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error)

	// DiffBranch request
	DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error)

	// HardResetBranch request
	HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error)

	// ImportCancel request
	ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error)

	// ImportStatus request
	ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error)

	// ImportStart request  with any body
	ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error)

	// DeleteObject request
	DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error)

	// UploadObject request  with any body
	UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error)

	// StageObject request  with any body
	StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error)

	// CopyObject request  with any body
	CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error)

	// DeleteObjects request  with any body
	DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error)

	// UploadObjectPreflight request
	UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error)

	// RevertBranch request  with any body
	RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error)

	// GetPhysicalAddress request
	GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error)

	// LinkPhysicalAddress request  with any body
	LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error)

	// CreatePresignMultipartUpload request
	CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error)

	// AbortPresignMultipartUpload request  with any body
	AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error)

	// CompletePresignMultipartUpload request  with any body
	CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error)

	// CreateCommitRecord request  with any body
	CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error)

	// GetCommit request
	GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error)

	// DumpStatus request
	DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error)

	// DumpSubmit request
	DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error)

	// PrepareGarbageCollectionCommits request
	PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error)

	// PrepareGarbageCollectionUncommitted request  with any body
	PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error)

	// InternalDeleteGarbageCollectionRules request
	InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error)

	// InternalGetGarbageCollectionRules request
	InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error)

	// InternalSetGarbageCollectionRules request  with any body
	InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error)

	// SetGarbageCollectionRulesPreflight request
	SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error)

	// DeleteRepositoryMetadata request  with any body
	DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error)

	// GetRepositoryMetadata request
	GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error)

	// SetRepositoryMetadata request  with any body
	SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error)

	// GetMetaRange request
	GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error)

	// GetRange request
	GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error)

	// DumpRefs request
	DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error)

	// RestoreRefs request  with any body
	RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error)

	// CreateSymlinkFile request
	CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error)

	// DiffRefs request
	DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error)

	// LogCommits request
	LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error)

	// GetObject request
	GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error)

	// HeadObject request
	HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error)

	// ListObjects request
	ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error)

	// StatObject request
	StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error)

	// GetUnderlyingProperties request
	GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error)

	// FindMergeBase request
	FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error)

	// MergeIntoBranch request  with any body
	MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error)

	// RestoreStatus request
	RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error)

	// RestoreSubmit request  with any body
	RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error)

	// GetBranchProtectionRules request
	GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error)

	// SetBranchProtectionRules request  with any body
	SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error)

	// DeleteGCRules request
	DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error)

	// GetGCRules request
	GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error)

	// SetGCRules request  with any body
	SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error)

	// ListTags request
	ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error)

	// CreateTag request  with any body
	CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error)

	// DeleteTag request
	DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error)

	// GetTag request
	GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error)

	// SetupCommPrefs request  with any body
	SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error)

	// GetSetupState request
	GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error)

	// Setup request  with any body
	SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error)

	// PostStatsEvents request  with any body
	PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error)

	// GetUsageReportSummary request
	GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error)

	// GetCurrentUser request
	GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error)
}

type GetAuthCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthCapabilities
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetAuthCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ACL
	JSON401      *Error
	JSON404      *ErrorNoACL
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGroupACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGroupACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGroupACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AddGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListGroupPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthenticationToken
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policy
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CredentialsWithSecret
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Credentials
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListUserPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachPolicyFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DetachPolicyFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachPolicyFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPolicyToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AttachPolicyToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPolicyToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGarbageCollectionConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetGarbageCollectionConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGarbageCollectionConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetStorageConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLakeFSVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionConfig
	JSON401      *Error
}

// Status returns HTTPResponse.Status
func (r GetLakeFSVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLakeFSVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryList
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Repository
	JSON400      *Error
	JSON401      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Repository
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRepositoryRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRunList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRepositoryRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRepositoryRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionRun
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRunHooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HookRunList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRunHooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRunHooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunHookOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRunHookOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunHookOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalCreateBranchProtectionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalCreateBranchProtectionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalCreateBranchProtectionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchProtectionRulePreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchProtectionRulePreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchProtectionRulePreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CherryPickResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CherryPickResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CherryPickResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HardResetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r HardResetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HardResetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportStatus
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ImportCreationResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ImportStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StageObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StageObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StageObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CopyObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectErrorList
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadObjectPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UploadObjectPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadObjectPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevertBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RevertBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevertBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StagingLocation
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LinkPhysicalAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LinkPhysicalAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LinkPhysicalAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PresignMultipartUpload
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreatePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortPresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AbortPresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortPresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompletePresignMultipartUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSON409      *StagingLocation
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CompletePresignMultipartUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompletePresignMultipartUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCommitRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateCommitRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommitRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Commit
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryDumpStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GarbageCollectionPrepareResponse
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrepareGarbageCollectionUncommittedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PrepareGCUncommittedResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PrepareGarbageCollectionUncommittedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrepareGarbageCollectionUncommittedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalDeleteGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalDeleteGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalDeleteGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalGetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalGetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalGetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InternalSetGarbageCollectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r InternalSetGarbageCollectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InternalSetGarbageCollectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGarbageCollectionRulesPreflightResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGarbageCollectionRulesPreflightResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGarbageCollectionRulesPreflightResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryMetadata
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetRepositoryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetRepositoryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetRepositoryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetaRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetMetaRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetaRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageURI
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DumpRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RefsDump
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DumpRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DumpRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSymlinkFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StorageURI
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateSymlinkFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSymlinkFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DiffRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DiffList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DiffRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DiffRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r LogCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON404      *Error
	JSON410      *Error
	JSON416      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r HeadObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListObjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStatsList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListObjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListObjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStats
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r StatObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnderlyingPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UnderlyingObjectProperties
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUnderlyingPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnderlyingPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindMergeBaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindMergeBaseResult
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r FindMergeBaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindMergeBaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIntoBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergeResult
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *MergeResult
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIntoBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIntoBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryRestoreStatus
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestoreSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TaskInfo
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r RestoreSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestoreSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchProtectionRule
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBranchProtectionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetBranchProtectionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBranchProtectionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GarbageCollectionRules
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetGCRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetGCRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetGCRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefList
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ref
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ref
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupCommPrefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON409      *Error
	JSON412      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupCommPrefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupCommPrefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSetupStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetupState
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSetupStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSetupStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CredentialsWithSecret
	JSON400      *Error
	JSON409      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SetupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostStatsEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostStatsEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostStatsEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageReportSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstallationUsageReport
	JSON400      *Error
	JSON401      *Error
	JSON404      *Error
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetUsageReportSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageReportSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CurrentUser
}

// Status returns HTTPResponse.Status
func (r GetCurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAuthCapabilitiesWithResponse request returning *GetAuthCapabilitiesResponse
func (c *ClientWithResponses) GetAuthCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCapabilitiesResponse, error) {
	rsp, err := c.GetAuthCapabilities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthCapabilitiesResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// GetGroupACLWithResponse request returning *GetGroupACLResponse
func (c *ClientWithResponses) GetGroupACLWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupACLResponse, error) {
	rsp, err := c.GetGroupACL(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupACLResponse(rsp)
}

// SetGroupACLWithBodyWithResponse request with arbitrary body returning *SetGroupACLResponse
func (c *ClientWithResponses) SetGroupACLWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACLWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

func (c *ClientWithResponses) SetGroupACLWithResponse(ctx context.Context, groupId string, body SetGroupACLJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGroupACLResponse, error) {
	rsp, err := c.SetGroupACL(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGroupACLResponse(rsp)
}

// ListGroupMembersWithResponse request returning *ListGroupMembersResponse
func (c *ClientWithResponses) ListGroupMembersWithResponse(ctx context.Context, groupId string, params *ListGroupMembersParams, reqEditors ...RequestEditorFn) (*ListGroupMembersResponse, error) {
	rsp, err := c.ListGroupMembers(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupMembersResponse(rsp)
}

// DeleteGroupMembershipWithResponse request returning *DeleteGroupMembershipResponse
func (c *ClientWithResponses) DeleteGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*DeleteGroupMembershipResponse, error) {
	rsp, err := c.DeleteGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupMembershipResponse(rsp)
}

// AddGroupMembershipWithResponse request returning *AddGroupMembershipResponse
func (c *ClientWithResponses) AddGroupMembershipWithResponse(ctx context.Context, groupId string, userId string, reqEditors ...RequestEditorFn) (*AddGroupMembershipResponse, error) {
	rsp, err := c.AddGroupMembership(ctx, groupId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupMembershipResponse(rsp)
}

// ListGroupPoliciesWithResponse request returning *ListGroupPoliciesResponse
func (c *ClientWithResponses) ListGroupPoliciesWithResponse(ctx context.Context, groupId string, params *ListGroupPoliciesParams, reqEditors ...RequestEditorFn) (*ListGroupPoliciesResponse, error) {
	rsp, err := c.ListGroupPolicies(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupPoliciesResponse(rsp)
}

// DetachPolicyFromGroupWithResponse request returning *DetachPolicyFromGroupResponse
func (c *ClientWithResponses) DetachPolicyFromGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromGroupResponse, error) {
	rsp, err := c.DetachPolicyFromGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromGroupResponse(rsp)
}

// AttachPolicyToGroupWithResponse request returning *AttachPolicyToGroupResponse
func (c *ClientWithResponses) AttachPolicyToGroupWithResponse(ctx context.Context, groupId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToGroupResponse, error) {
	rsp, err := c.AttachPolicyToGroup(ctx, groupId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToGroupResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// CreatePolicyWithBodyWithResponse request with arbitrary body returning *CreatePolicyResponse
func (c *ClientWithResponses) CreatePolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePolicyWithResponse(ctx context.Context, body CreatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePolicyResponse, error) {
	rsp, err := c.CreatePolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePolicyResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policyId string, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policyId string, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListUserCredentialsWithResponse request returning *ListUserCredentialsResponse
func (c *ClientWithResponses) ListUserCredentialsWithResponse(ctx context.Context, userId string, params *ListUserCredentialsParams, reqEditors ...RequestEditorFn) (*ListUserCredentialsResponse, error) {
	rsp, err := c.ListUserCredentials(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserCredentialsResponse(rsp)
}

// CreateCredentialsWithResponse request returning *CreateCredentialsResponse
func (c *ClientWithResponses) CreateCredentialsWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*CreateCredentialsResponse, error) {
	rsp, err := c.CreateCredentials(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCredentialsResponse(rsp)
}

// DeleteCredentialsWithResponse request returning *DeleteCredentialsResponse
func (c *ClientWithResponses) DeleteCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*DeleteCredentialsResponse, error) {
	rsp, err := c.DeleteCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCredentialsResponse(rsp)
}

// GetCredentialsWithResponse request returning *GetCredentialsResponse
func (c *ClientWithResponses) GetCredentialsWithResponse(ctx context.Context, userId string, accessKeyId string, reqEditors ...RequestEditorFn) (*GetCredentialsResponse, error) {
	rsp, err := c.GetCredentials(ctx, userId, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCredentialsResponse(rsp)
}

// ListUserGroupsWithResponse request returning *ListUserGroupsResponse
func (c *ClientWithResponses) ListUserGroupsWithResponse(ctx context.Context, userId string, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error) {
	rsp, err := c.ListUserGroups(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserGroupsResponse(rsp)
}

// ListUserPoliciesWithResponse request returning *ListUserPoliciesResponse
func (c *ClientWithResponses) ListUserPoliciesWithResponse(ctx context.Context, userId string, params *ListUserPoliciesParams, reqEditors ...RequestEditorFn) (*ListUserPoliciesResponse, error) {
	rsp, err := c.ListUserPolicies(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserPoliciesResponse(rsp)
}

// DetachPolicyFromUserWithResponse request returning *DetachPolicyFromUserResponse
func (c *ClientWithResponses) DetachPolicyFromUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*DetachPolicyFromUserResponse, error) {
	rsp, err := c.DetachPolicyFromUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachPolicyFromUserResponse(rsp)
}

// AttachPolicyToUserWithResponse request returning *AttachPolicyToUserResponse
func (c *ClientWithResponses) AttachPolicyToUserWithResponse(ctx context.Context, userId string, policyId string, reqEditors ...RequestEditorFn) (*AttachPolicyToUserResponse, error) {
	rsp, err := c.AttachPolicyToUser(ctx, userId, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPolicyToUserResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetGarbageCollectionConfigWithResponse request returning *GetGarbageCollectionConfigResponse
func (c *ClientWithResponses) GetGarbageCollectionConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGarbageCollectionConfigResponse, error) {
	rsp, err := c.GetGarbageCollectionConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGarbageCollectionConfigResponse(rsp)
}

// GetStorageConfigWithResponse request returning *GetStorageConfigResponse
func (c *ClientWithResponses) GetStorageConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageConfigResponse, error) {
	rsp, err := c.GetStorageConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageConfigResponse(rsp)
}

// GetLakeFSVersionWithResponse request returning *GetLakeFSVersionResponse
func (c *ClientWithResponses) GetLakeFSVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLakeFSVersionResponse, error) {
	rsp, err := c.GetLakeFSVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLakeFSVersionResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// ListRepositoriesWithResponse request returning *ListRepositoriesResponse
func (c *ClientWithResponses) ListRepositoriesWithResponse(ctx context.Context, params *ListRepositoriesParams, reqEditors ...RequestEditorFn) (*ListRepositoriesResponse, error) {
	rsp, err := c.ListRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoriesResponse(rsp)
}

// CreateRepositoryWithBodyWithResponse request with arbitrary body returning *CreateRepositoryResponse
func (c *ClientWithResponses) CreateRepositoryWithBodyWithResponse(ctx context.Context, params *CreateRepositoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepositoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

func (c *ClientWithResponses) CreateRepositoryWithResponse(ctx context.Context, params *CreateRepositoryParams, body CreateRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRepositoryResponse, error) {
	rsp, err := c.CreateRepository(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRepositoryResponse(rsp)
}

// DeleteRepositoryWithResponse request returning *DeleteRepositoryResponse
func (c *ClientWithResponses) DeleteRepositoryWithResponse(ctx context.Context, repository string, params *DeleteRepositoryParams, reqEditors ...RequestEditorFn) (*DeleteRepositoryResponse, error) {
	rsp, err := c.DeleteRepository(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryResponse(rsp)
}

// GetRepositoryWithResponse request returning *GetRepositoryResponse
func (c *ClientWithResponses) GetRepositoryWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryResponse, error) {
	rsp, err := c.GetRepository(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryResponse(rsp)
}

// ListRepositoryRunsWithResponse request returning *ListRepositoryRunsResponse
func (c *ClientWithResponses) ListRepositoryRunsWithResponse(ctx context.Context, repository string, params *ListRepositoryRunsParams, reqEditors ...RequestEditorFn) (*ListRepositoryRunsResponse, error) {
	rsp, err := c.ListRepositoryRuns(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRepositoryRunsResponse(rsp)
}

// GetRunWithResponse request returning *GetRunResponse
func (c *ClientWithResponses) GetRunWithResponse(ctx context.Context, repository string, runId string, reqEditors ...RequestEditorFn) (*GetRunResponse, error) {
	rsp, err := c.GetRun(ctx, repository, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunResponse(rsp)
}

// ListRunHooksWithResponse request returning *ListRunHooksResponse
func (c *ClientWithResponses) ListRunHooksWithResponse(ctx context.Context, repository string, runId string, params *ListRunHooksParams, reqEditors ...RequestEditorFn) (*ListRunHooksResponse, error) {
	rsp, err := c.ListRunHooks(ctx, repository, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRunHooksResponse(rsp)
}

// GetRunHookOutputWithResponse request returning *GetRunHookOutputResponse
func (c *ClientWithResponses) GetRunHookOutputWithResponse(ctx context.Context, repository string, runId string, hookRunId string, reqEditors ...RequestEditorFn) (*GetRunHookOutputResponse, error) {
	rsp, err := c.GetRunHookOutput(ctx, repository, runId, hookRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunHookOutputResponse(rsp)
}

// InternalDeleteBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalDeleteBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalDeleteBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalDeleteBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalDeleteBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalDeleteBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteBranchProtectionRuleResponse(rsp)
}

// InternalGetBranchProtectionRulesWithResponse request returning *InternalGetBranchProtectionRulesResponse
func (c *ClientWithResponses) InternalGetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetBranchProtectionRulesResponse, error) {
	rsp, err := c.InternalGetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetBranchProtectionRulesResponse(rsp)
}

// InternalCreateBranchProtectionRuleWithBodyWithResponse request with arbitrary body returning *InternalCreateBranchProtectionRuleResponse
func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRuleWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

func (c *ClientWithResponses) InternalCreateBranchProtectionRuleWithResponse(ctx context.Context, repository string, body InternalCreateBranchProtectionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalCreateBranchProtectionRuleResponse, error) {
	rsp, err := c.InternalCreateBranchProtectionRule(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalCreateBranchProtectionRuleResponse(rsp)
}

// CreateBranchProtectionRulePreflightWithResponse request returning *CreateBranchProtectionRulePreflightResponse
func (c *ClientWithResponses) CreateBranchProtectionRulePreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*CreateBranchProtectionRulePreflightResponse, error) {
	rsp, err := c.CreateBranchProtectionRulePreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchProtectionRulePreflightResponse(rsp)
}

// ListBranchesWithResponse request returning *ListBranchesResponse
func (c *ClientWithResponses) ListBranchesWithResponse(ctx context.Context, repository string, params *ListBranchesParams, reqEditors ...RequestEditorFn) (*ListBranchesResponse, error) {
	rsp, err := c.ListBranches(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBranchesResponse(rsp)
}

// CreateBranchWithBodyWithResponse request with arbitrary body returning *CreateBranchResponse
func (c *ClientWithResponses) CreateBranchWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranchWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

func (c *ClientWithResponses) CreateBranchWithResponse(ctx context.Context, repository string, body CreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBranchResponse, error) {
	rsp, err := c.CreateBranch(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBranchResponse(rsp)
}

// DeleteBranchWithResponse request returning *DeleteBranchResponse
func (c *ClientWithResponses) DeleteBranchWithResponse(ctx context.Context, repository string, branch string, params *DeleteBranchParams, reqEditors ...RequestEditorFn) (*DeleteBranchResponse, error) {
	rsp, err := c.DeleteBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBranchResponse(rsp)
}

// GetBranchWithResponse request returning *GetBranchResponse
func (c *ClientWithResponses) GetBranchWithResponse(ctx context.Context, repository string, branch string, reqEditors ...RequestEditorFn) (*GetBranchResponse, error) {
	rsp, err := c.GetBranch(ctx, repository, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchResponse(rsp)
}

// ResetBranchWithBodyWithResponse request with arbitrary body returning *ResetBranchResponse
func (c *ClientWithResponses) ResetBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

func (c *ClientWithResponses) ResetBranchWithResponse(ctx context.Context, repository string, branch string, body ResetBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetBranchResponse, error) {
	rsp, err := c.ResetBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetBranchResponse(rsp)
}

// CherryPickWithBodyWithResponse request with arbitrary body returning *CherryPickResponse
func (c *ClientWithResponses) CherryPickWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPickWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

func (c *ClientWithResponses) CherryPickWithResponse(ctx context.Context, repository string, branch string, body CherryPickJSONRequestBody, reqEditors ...RequestEditorFn) (*CherryPickResponse, error) {
	rsp, err := c.CherryPick(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCherryPickResponse(rsp)
}

// CommitWithBodyWithResponse request with arbitrary body returning *CommitResponse
func (c *ClientWithResponses) CommitWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.CommitWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

func (c *ClientWithResponses) CommitWithResponse(ctx context.Context, repository string, branch string, params *CommitParams, body CommitJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitResponse, error) {
	rsp, err := c.Commit(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitResponse(rsp)
}

// DiffBranchWithResponse request returning *DiffBranchResponse
func (c *ClientWithResponses) DiffBranchWithResponse(ctx context.Context, repository string, branch string, params *DiffBranchParams, reqEditors ...RequestEditorFn) (*DiffBranchResponse, error) {
	rsp, err := c.DiffBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffBranchResponse(rsp)
}

// HardResetBranchWithResponse request returning *HardResetBranchResponse
func (c *ClientWithResponses) HardResetBranchWithResponse(ctx context.Context, repository string, branch string, params *HardResetBranchParams, reqEditors ...RequestEditorFn) (*HardResetBranchResponse, error) {
	rsp, err := c.HardResetBranch(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHardResetBranchResponse(rsp)
}

// ImportCancelWithResponse request returning *ImportCancelResponse
func (c *ClientWithResponses) ImportCancelWithResponse(ctx context.Context, repository string, branch string, params *ImportCancelParams, reqEditors ...RequestEditorFn) (*ImportCancelResponse, error) {
	rsp, err := c.ImportCancel(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportCancelResponse(rsp)
}

// ImportStatusWithResponse request returning *ImportStatusResponse
func (c *ClientWithResponses) ImportStatusWithResponse(ctx context.Context, repository string, branch string, params *ImportStatusParams, reqEditors ...RequestEditorFn) (*ImportStatusResponse, error) {
	rsp, err := c.ImportStatus(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStatusResponse(rsp)
}

// ImportStartWithBodyWithResponse request with arbitrary body returning *ImportStartResponse
func (c *ClientWithResponses) ImportStartWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStartWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

func (c *ClientWithResponses) ImportStartWithResponse(ctx context.Context, repository string, branch string, body ImportStartJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportStartResponse, error) {
	rsp, err := c.ImportStart(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportStartResponse(rsp)
}

// DeleteObjectWithResponse request returning *DeleteObjectResponse
func (c *ClientWithResponses) DeleteObjectWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectParams, reqEditors ...RequestEditorFn) (*DeleteObjectResponse, error) {
	rsp, err := c.DeleteObject(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectResponse(rsp)
}

// UploadObjectWithBodyWithResponse request with arbitrary body returning *UploadObjectResponse
func (c *ClientWithResponses) UploadObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadObjectResponse, error) {
	rsp, err := c.UploadObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectResponse(rsp)
}

// StageObjectWithBodyWithResponse request with arbitrary body returning *StageObjectResponse
func (c *ClientWithResponses) StageObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

func (c *ClientWithResponses) StageObjectWithResponse(ctx context.Context, repository string, branch string, params *StageObjectParams, body StageObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*StageObjectResponse, error) {
	rsp, err := c.StageObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStageObjectResponse(rsp)
}

// CopyObjectWithBodyWithResponse request with arbitrary body returning *CopyObjectResponse
func (c *ClientWithResponses) CopyObjectWithBodyWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObjectWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

func (c *ClientWithResponses) CopyObjectWithResponse(ctx context.Context, repository string, branch string, params *CopyObjectParams, body CopyObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyObjectResponse, error) {
	rsp, err := c.CopyObject(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyObjectResponse(rsp)
}

// DeleteObjectsWithBodyWithResponse request with arbitrary body returning *DeleteObjectsResponse
func (c *ClientWithResponses) DeleteObjectsWithBodyWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjectsWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

func (c *ClientWithResponses) DeleteObjectsWithResponse(ctx context.Context, repository string, branch string, params *DeleteObjectsParams, body DeleteObjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteObjectsResponse, error) {
	rsp, err := c.DeleteObjects(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteObjectsResponse(rsp)
}

// UploadObjectPreflightWithResponse request returning *UploadObjectPreflightResponse
func (c *ClientWithResponses) UploadObjectPreflightWithResponse(ctx context.Context, repository string, branch string, params *UploadObjectPreflightParams, reqEditors ...RequestEditorFn) (*UploadObjectPreflightResponse, error) {
	rsp, err := c.UploadObjectPreflight(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadObjectPreflightResponse(rsp)
}

// RevertBranchWithBodyWithResponse request with arbitrary body returning *RevertBranchResponse
func (c *ClientWithResponses) RevertBranchWithBodyWithResponse(ctx context.Context, repository string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranchWithBody(ctx, repository, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

func (c *ClientWithResponses) RevertBranchWithResponse(ctx context.Context, repository string, branch string, body RevertBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*RevertBranchResponse, error) {
	rsp, err := c.RevertBranch(ctx, repository, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertBranchResponse(rsp)
}

// GetPhysicalAddressWithResponse request returning *GetPhysicalAddressResponse
func (c *ClientWithResponses) GetPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *GetPhysicalAddressParams, reqEditors ...RequestEditorFn) (*GetPhysicalAddressResponse, error) {
	rsp, err := c.GetPhysicalAddress(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPhysicalAddressResponse(rsp)
}

// LinkPhysicalAddressWithBodyWithResponse request with arbitrary body returning *LinkPhysicalAddressResponse
func (c *ClientWithResponses) LinkPhysicalAddressWithBodyWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddressWithBody(ctx, repository, branch, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

func (c *ClientWithResponses) LinkPhysicalAddressWithResponse(ctx context.Context, repository string, branch string, params *LinkPhysicalAddressParams, body LinkPhysicalAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*LinkPhysicalAddressResponse, error) {
	rsp, err := c.LinkPhysicalAddress(ctx, repository, branch, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLinkPhysicalAddressResponse(rsp)
}

// CreatePresignMultipartUploadWithResponse request returning *CreatePresignMultipartUploadResponse
func (c *ClientWithResponses) CreatePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, params *CreatePresignMultipartUploadParams, reqEditors ...RequestEditorFn) (*CreatePresignMultipartUploadResponse, error) {
	rsp, err := c.CreatePresignMultipartUpload(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePresignMultipartUploadResponse(rsp)
}

// AbortPresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *AbortPresignMultipartUploadResponse
func (c *ClientWithResponses) AbortPresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) AbortPresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *AbortPresignMultipartUploadParams, body AbortPresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*AbortPresignMultipartUploadResponse, error) {
	rsp, err := c.AbortPresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortPresignMultipartUploadResponse(rsp)
}

// CompletePresignMultipartUploadWithBodyWithResponse request with arbitrary body returning *CompletePresignMultipartUploadResponse
func (c *ClientWithResponses) CompletePresignMultipartUploadWithBodyWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUploadWithBody(ctx, repository, branch, uploadId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

func (c *ClientWithResponses) CompletePresignMultipartUploadWithResponse(ctx context.Context, repository string, branch string, uploadId string, params *CompletePresignMultipartUploadParams, body CompletePresignMultipartUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*CompletePresignMultipartUploadResponse, error) {
	rsp, err := c.CompletePresignMultipartUpload(ctx, repository, branch, uploadId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompletePresignMultipartUploadResponse(rsp)
}

// CreateCommitRecordWithBodyWithResponse request with arbitrary body returning *CreateCommitRecordResponse
func (c *ClientWithResponses) CreateCommitRecordWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecordWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

func (c *ClientWithResponses) CreateCommitRecordWithResponse(ctx context.Context, repository string, body CreateCommitRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCommitRecordResponse, error) {
	rsp, err := c.CreateCommitRecord(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCommitRecordResponse(rsp)
}

// GetCommitWithResponse request returning *GetCommitResponse
func (c *ClientWithResponses) GetCommitWithResponse(ctx context.Context, repository string, commitId string, reqEditors ...RequestEditorFn) (*GetCommitResponse, error) {
	rsp, err := c.GetCommit(ctx, repository, commitId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommitResponse(rsp)
}

// DumpStatusWithResponse request returning *DumpStatusResponse
func (c *ClientWithResponses) DumpStatusWithResponse(ctx context.Context, repository string, params *DumpStatusParams, reqEditors ...RequestEditorFn) (*DumpStatusResponse, error) {
	rsp, err := c.DumpStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpStatusResponse(rsp)
}

// DumpSubmitWithResponse request returning *DumpSubmitResponse
func (c *ClientWithResponses) DumpSubmitWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpSubmitResponse, error) {
	rsp, err := c.DumpSubmit(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpSubmitResponse(rsp)
}

// PrepareGarbageCollectionCommitsWithResponse request returning *PrepareGarbageCollectionCommitsResponse
func (c *ClientWithResponses) PrepareGarbageCollectionCommitsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionCommitsResponse, error) {
	rsp, err := c.PrepareGarbageCollectionCommits(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionCommitsResponse(rsp)
}

// PrepareGarbageCollectionUncommittedWithBodyWithResponse request with arbitrary body returning *PrepareGarbageCollectionUncommittedResponse
func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommittedWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

func (c *ClientWithResponses) PrepareGarbageCollectionUncommittedWithResponse(ctx context.Context, repository string, body PrepareGarbageCollectionUncommittedJSONRequestBody, reqEditors ...RequestEditorFn) (*PrepareGarbageCollectionUncommittedResponse, error) {
	rsp, err := c.PrepareGarbageCollectionUncommitted(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrepareGarbageCollectionUncommittedResponse(rsp)
}

// InternalDeleteGarbageCollectionRulesWithResponse request returning *InternalDeleteGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalDeleteGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalDeleteGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalDeleteGarbageCollectionRulesResponse(rsp)
}

// InternalGetGarbageCollectionRulesWithResponse request returning *InternalGetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalGetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*InternalGetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalGetGarbageCollectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalGetGarbageCollectionRulesResponse(rsp)
}

// InternalSetGarbageCollectionRulesWithBodyWithResponse request with arbitrary body returning *InternalSetGarbageCollectionRulesResponse
func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

func (c *ClientWithResponses) InternalSetGarbageCollectionRulesWithResponse(ctx context.Context, repository string, body InternalSetGarbageCollectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*InternalSetGarbageCollectionRulesResponse, error) {
	rsp, err := c.InternalSetGarbageCollectionRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInternalSetGarbageCollectionRulesResponse(rsp)
}

// SetGarbageCollectionRulesPreflightWithResponse request returning *SetGarbageCollectionRulesPreflightResponse
func (c *ClientWithResponses) SetGarbageCollectionRulesPreflightWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*SetGarbageCollectionRulesPreflightResponse, error) {
	rsp, err := c.SetGarbageCollectionRulesPreflight(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGarbageCollectionRulesPreflightResponse(rsp)
}

// DeleteRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *DeleteRepositoryMetadataResponse
func (c *ClientWithResponses) DeleteRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) DeleteRepositoryMetadataWithResponse(ctx context.Context, repository string, body DeleteRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRepositoryMetadataResponse, error) {
	rsp, err := c.DeleteRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepositoryMetadataResponse(rsp)
}

// GetRepositoryMetadataWithResponse request returning *GetRepositoryMetadataResponse
func (c *ClientWithResponses) GetRepositoryMetadataWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetRepositoryMetadataResponse, error) {
	rsp, err := c.GetRepositoryMetadata(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRepositoryMetadataResponse(rsp)
}

// SetRepositoryMetadataWithBodyWithResponse request with arbitrary body returning *SetRepositoryMetadataResponse
func (c *ClientWithResponses) SetRepositoryMetadataWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadataWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

func (c *ClientWithResponses) SetRepositoryMetadataWithResponse(ctx context.Context, repository string, body SetRepositoryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*SetRepositoryMetadataResponse, error) {
	rsp, err := c.SetRepositoryMetadata(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetRepositoryMetadataResponse(rsp)
}

// GetMetaRangeWithResponse request returning *GetMetaRangeResponse
func (c *ClientWithResponses) GetMetaRangeWithResponse(ctx context.Context, repository string, metaRange string, reqEditors ...RequestEditorFn) (*GetMetaRangeResponse, error) {
	rsp, err := c.GetMetaRange(ctx, repository, metaRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetaRangeResponse(rsp)
}

// GetRangeWithResponse request returning *GetRangeResponse
func (c *ClientWithResponses) GetRangeWithResponse(ctx context.Context, repository string, pRange string, reqEditors ...RequestEditorFn) (*GetRangeResponse, error) {
	rsp, err := c.GetRange(ctx, repository, pRange, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRangeResponse(rsp)
}

// DumpRefsWithResponse request returning *DumpRefsResponse
func (c *ClientWithResponses) DumpRefsWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DumpRefsResponse, error) {
	rsp, err := c.DumpRefs(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDumpRefsResponse(rsp)
}

// RestoreRefsWithBodyWithResponse request with arbitrary body returning *RestoreRefsResponse
func (c *ClientWithResponses) RestoreRefsWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefsWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

func (c *ClientWithResponses) RestoreRefsWithResponse(ctx context.Context, repository string, body RestoreRefsJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreRefsResponse, error) {
	rsp, err := c.RestoreRefs(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreRefsResponse(rsp)
}

// CreateSymlinkFileWithResponse request returning *CreateSymlinkFileResponse
func (c *ClientWithResponses) CreateSymlinkFileWithResponse(ctx context.Context, repository string, branch string, params *CreateSymlinkFileParams, reqEditors ...RequestEditorFn) (*CreateSymlinkFileResponse, error) {
	rsp, err := c.CreateSymlinkFile(ctx, repository, branch, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSymlinkFileResponse(rsp)
}

// DiffRefsWithResponse request returning *DiffRefsResponse
func (c *ClientWithResponses) DiffRefsWithResponse(ctx context.Context, repository string, leftRef string, rightRef string, params *DiffRefsParams, reqEditors ...RequestEditorFn) (*DiffRefsResponse, error) {
	rsp, err := c.DiffRefs(ctx, repository, leftRef, rightRef, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDiffRefsResponse(rsp)
}

// LogCommitsWithResponse request returning *LogCommitsResponse
func (c *ClientWithResponses) LogCommitsWithResponse(ctx context.Context, repository string, ref string, params *LogCommitsParams, reqEditors ...RequestEditorFn) (*LogCommitsResponse, error) {
	rsp, err := c.LogCommits(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogCommitsResponse(rsp)
}

// GetObjectWithResponse request returning *GetObjectResponse
func (c *ClientWithResponses) GetObjectWithResponse(ctx context.Context, repository string, ref string, params *GetObjectParams, reqEditors ...RequestEditorFn) (*GetObjectResponse, error) {
	rsp, err := c.GetObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetObjectResponse(rsp)
}

// HeadObjectWithResponse request returning *HeadObjectResponse
func (c *ClientWithResponses) HeadObjectWithResponse(ctx context.Context, repository string, ref string, params *HeadObjectParams, reqEditors ...RequestEditorFn) (*HeadObjectResponse, error) {
	rsp, err := c.HeadObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadObjectResponse(rsp)
}

// ListObjectsWithResponse request returning *ListObjectsResponse
func (c *ClientWithResponses) ListObjectsWithResponse(ctx context.Context, repository string, ref string, params *ListObjectsParams, reqEditors ...RequestEditorFn) (*ListObjectsResponse, error) {
	rsp, err := c.ListObjects(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListObjectsResponse(rsp)
}

// StatObjectWithResponse request returning *StatObjectResponse
func (c *ClientWithResponses) StatObjectWithResponse(ctx context.Context, repository string, ref string, params *StatObjectParams, reqEditors ...RequestEditorFn) (*StatObjectResponse, error) {
	rsp, err := c.StatObject(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatObjectResponse(rsp)
}

// GetUnderlyingPropertiesWithResponse request returning *GetUnderlyingPropertiesResponse
func (c *ClientWithResponses) GetUnderlyingPropertiesWithResponse(ctx context.Context, repository string, ref string, params *GetUnderlyingPropertiesParams, reqEditors ...RequestEditorFn) (*GetUnderlyingPropertiesResponse, error) {
	rsp, err := c.GetUnderlyingProperties(ctx, repository, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnderlyingPropertiesResponse(rsp)
}

// FindMergeBaseWithResponse request returning *FindMergeBaseResponse
func (c *ClientWithResponses) FindMergeBaseWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, reqEditors ...RequestEditorFn) (*FindMergeBaseResponse, error) {
	rsp, err := c.FindMergeBase(ctx, repository, sourceRef, destinationBranch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindMergeBaseResponse(rsp)
}

// MergeIntoBranchWithBodyWithResponse request with arbitrary body returning *MergeIntoBranchResponse
func (c *ClientWithResponses) MergeIntoBranchWithBodyWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranchWithBody(ctx, repository, sourceRef, destinationBranch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

func (c *ClientWithResponses) MergeIntoBranchWithResponse(ctx context.Context, repository string, sourceRef string, destinationBranch string, body MergeIntoBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIntoBranchResponse, error) {
	rsp, err := c.MergeIntoBranch(ctx, repository, sourceRef, destinationBranch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIntoBranchResponse(rsp)
}

// RestoreStatusWithResponse request returning *RestoreStatusResponse
func (c *ClientWithResponses) RestoreStatusWithResponse(ctx context.Context, repository string, params *RestoreStatusParams, reqEditors ...RequestEditorFn) (*RestoreStatusResponse, error) {
	rsp, err := c.RestoreStatus(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreStatusResponse(rsp)
}

// RestoreSubmitWithBodyWithResponse request with arbitrary body returning *RestoreSubmitResponse
func (c *ClientWithResponses) RestoreSubmitWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmitWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

func (c *ClientWithResponses) RestoreSubmitWithResponse(ctx context.Context, repository string, body RestoreSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*RestoreSubmitResponse, error) {
	rsp, err := c.RestoreSubmit(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestoreSubmitResponse(rsp)
}

// GetBranchProtectionRulesWithResponse request returning *GetBranchProtectionRulesResponse
func (c *ClientWithResponses) GetBranchProtectionRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetBranchProtectionRulesResponse, error) {
	rsp, err := c.GetBranchProtectionRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBranchProtectionRulesResponse(rsp)
}

// SetBranchProtectionRulesWithBodyWithResponse request with arbitrary body returning *SetBranchProtectionRulesResponse
func (c *ClientWithResponses) SetBranchProtectionRulesWithBodyWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRulesWithBody(ctx, repository, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

func (c *ClientWithResponses) SetBranchProtectionRulesWithResponse(ctx context.Context, repository string, params *SetBranchProtectionRulesParams, body SetBranchProtectionRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBranchProtectionRulesResponse, error) {
	rsp, err := c.SetBranchProtectionRules(ctx, repository, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBranchProtectionRulesResponse(rsp)
}

// DeleteGCRulesWithResponse request returning *DeleteGCRulesResponse
func (c *ClientWithResponses) DeleteGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*DeleteGCRulesResponse, error) {
	rsp, err := c.DeleteGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGCRulesResponse(rsp)
}

// GetGCRulesWithResponse request returning *GetGCRulesResponse
func (c *ClientWithResponses) GetGCRulesWithResponse(ctx context.Context, repository string, reqEditors ...RequestEditorFn) (*GetGCRulesResponse, error) {
	rsp, err := c.GetGCRules(ctx, repository, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGCRulesResponse(rsp)
}

// SetGCRulesWithBodyWithResponse request with arbitrary body returning *SetGCRulesResponse
func (c *ClientWithResponses) SetGCRulesWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRulesWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

func (c *ClientWithResponses) SetGCRulesWithResponse(ctx context.Context, repository string, body SetGCRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetGCRulesResponse, error) {
	rsp, err := c.SetGCRules(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetGCRulesResponse(rsp)
}

// ListTagsWithResponse request returning *ListTagsResponse
func (c *ClientWithResponses) ListTagsWithResponse(ctx context.Context, repository string, params *ListTagsParams, reqEditors ...RequestEditorFn) (*ListTagsResponse, error) {
	rsp, err := c.ListTags(ctx, repository, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTagsResponse(rsp)
}

// CreateTagWithBodyWithResponse request with arbitrary body returning *CreateTagResponse
func (c *ClientWithResponses) CreateTagWithBodyWithResponse(ctx context.Context, repository string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTagWithBody(ctx, repository, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

func (c *ClientWithResponses) CreateTagWithResponse(ctx context.Context, repository string, body CreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTagResponse, error) {
	rsp, err := c.CreateTag(ctx, repository, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTagResponse(rsp)
}

// DeleteTagWithResponse request returning *DeleteTagResponse
func (c *ClientWithResponses) DeleteTagWithResponse(ctx context.Context, repository string, tag string, params *DeleteTagParams, reqEditors ...RequestEditorFn) (*DeleteTagResponse, error) {
	rsp, err := c.DeleteTag(ctx, repository, tag, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagResponse(rsp)
}

// GetTagWithResponse request returning *GetTagResponse
func (c *ClientWithResponses) GetTagWithResponse(ctx context.Context, repository string, tag string, reqEditors ...RequestEditorFn) (*GetTagResponse, error) {
	rsp, err := c.GetTag(ctx, repository, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagResponse(rsp)
}

// SetupCommPrefsWithBodyWithResponse request with arbitrary body returning *SetupCommPrefsResponse
func (c *ClientWithResponses) SetupCommPrefsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

func (c *ClientWithResponses) SetupCommPrefsWithResponse(ctx context.Context, body SetupCommPrefsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupCommPrefsResponse, error) {
	rsp, err := c.SetupCommPrefs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupCommPrefsResponse(rsp)
}

// GetSetupStateWithResponse request returning *GetSetupStateResponse
func (c *ClientWithResponses) GetSetupStateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSetupStateResponse, error) {
	rsp, err := c.GetSetupState(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSetupStateResponse(rsp)
}

// SetupWithBodyWithResponse request with arbitrary body returning *SetupResponse
func (c *ClientWithResponses) SetupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.SetupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

func (c *ClientWithResponses) SetupWithResponse(ctx context.Context, body SetupJSONRequestBody, reqEditors ...RequestEditorFn) (*SetupResponse, error) {
	rsp, err := c.Setup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetupResponse(rsp)
}

// PostStatsEventsWithBodyWithResponse request with arbitrary body returning *PostStatsEventsResponse
func (c *ClientWithResponses) PostStatsEventsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEventsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

func (c *ClientWithResponses) PostStatsEventsWithResponse(ctx context.Context, body PostStatsEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostStatsEventsResponse, error) {
	rsp, err := c.PostStatsEvents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostStatsEventsResponse(rsp)
}

// GetUsageReportSummaryWithResponse request returning *GetUsageReportSummaryResponse
func (c *ClientWithResponses) GetUsageReportSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUsageReportSummaryResponse, error) {
	rsp, err := c.GetUsageReportSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageReportSummaryResponse(rsp)
}

// GetCurrentUserWithResponse request returning *GetCurrentUserResponse
func (c *ClientWithResponses) GetCurrentUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCurrentUserResponse, error) {
	rsp, err := c.GetCurrentUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentUserResponse(rsp)
}

// ParseGetAuthCapabilitiesResponse parses an HTTP response from a GetAuthCapabilitiesWithResponse call
func ParseGetAuthCapabilitiesResponse(rsp *http.Response) (*GetAuthCapabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetAuthCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthCapabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupACLResponse parses an HTTP response from a GetGroupACLWithResponse call
func ParseGetGroupACLResponse(rsp *http.Response) (*GetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorNoACL
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGroupACLResponse parses an HTTP response from a SetGroupACLWithResponse call
func ParseSetGroupACLResponse(rsp *http.Response) (*SetGroupACLResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGroupACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupMembersResponse parses an HTTP response from a ListGroupMembersWithResponse call
func ParseListGroupMembersResponse(rsp *http.Response) (*ListGroupMembersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupMembershipResponse parses an HTTP response from a DeleteGroupMembershipWithResponse call
func ParseDeleteGroupMembershipResponse(rsp *http.Response) (*DeleteGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddGroupMembershipResponse parses an HTTP response from a AddGroupMembershipWithResponse call
func ParseAddGroupMembershipResponse(rsp *http.Response) (*AddGroupMembershipResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListGroupPoliciesResponse parses an HTTP response from a ListGroupPoliciesWithResponse call
func ParseListGroupPoliciesResponse(rsp *http.Response) (*ListGroupPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListGroupPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromGroupResponse parses an HTTP response from a DetachPolicyFromGroupWithResponse call
func ParseDetachPolicyFromGroupResponse(rsp *http.Response) (*DetachPolicyFromGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToGroupResponse parses an HTTP response from a AttachPolicyToGroupWithResponse call
func ParseAttachPolicyToGroupResponse(rsp *http.Response) (*AttachPolicyToGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePolicyResponse parses an HTTP response from a CreatePolicyWithResponse call
func ParseCreatePolicyResponse(rsp *http.Response) (*CreatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserCredentialsResponse parses an HTTP response from a ListUserCredentialsWithResponse call
func ParseListUserCredentialsResponse(rsp *http.Response) (*ListUserCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCredentialsResponse parses an HTTP response from a CreateCredentialsWithResponse call
func ParseCreateCredentialsResponse(rsp *http.Response) (*CreateCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCredentialsResponse parses an HTTP response from a DeleteCredentialsWithResponse call
func ParseDeleteCredentialsResponse(rsp *http.Response) (*DeleteCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCredentialsResponse parses an HTTP response from a GetCredentialsWithResponse call
func ParseGetCredentialsResponse(rsp *http.Response) (*GetCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Credentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserGroupsResponse parses an HTTP response from a ListUserGroupsWithResponse call
func ParseListUserGroupsResponse(rsp *http.Response) (*ListUserGroupsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserPoliciesResponse parses an HTTP response from a ListUserPoliciesWithResponse call
func ParseListUserPoliciesResponse(rsp *http.Response) (*ListUserPoliciesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListUserPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDetachPolicyFromUserResponse parses an HTTP response from a DetachPolicyFromUserWithResponse call
func ParseDetachPolicyFromUserResponse(rsp *http.Response) (*DetachPolicyFromUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DetachPolicyFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPolicyToUserResponse parses an HTTP response from a AttachPolicyToUserWithResponse call
func ParseAttachPolicyToUserResponse(rsp *http.Response) (*AttachPolicyToUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AttachPolicyToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetGarbageCollectionConfigResponse parses an HTTP response from a GetGarbageCollectionConfigWithResponse call
func ParseGetGarbageCollectionConfigResponse(rsp *http.Response) (*GetGarbageCollectionConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGarbageCollectionConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetStorageConfigResponse parses an HTTP response from a GetStorageConfigWithResponse call
func ParseGetStorageConfigResponse(rsp *http.Response) (*GetStorageConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetStorageConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetLakeFSVersionResponse parses an HTTP response from a GetLakeFSVersionWithResponse call
func ParseGetLakeFSVersionResponse(rsp *http.Response) (*GetLakeFSVersionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetLakeFSVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListRepositoriesResponse parses an HTTP response from a ListRepositoriesWithResponse call
func ParseListRepositoriesResponse(rsp *http.Response) (*ListRepositoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRepositoryResponse parses an HTTP response from a CreateRepositoryWithResponse call
func ParseCreateRepositoryResponse(rsp *http.Response) (*CreateRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryResponse parses an HTTP response from a DeleteRepositoryWithResponse call
func ParseDeleteRepositoryResponse(rsp *http.Response) (*DeleteRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryResponse parses an HTTP response from a GetRepositoryWithResponse call
func ParseGetRepositoryResponse(rsp *http.Response) (*GetRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRepositoryRunsResponse parses an HTTP response from a ListRepositoryRunsWithResponse call
func ParseListRepositoryRunsResponse(rsp *http.Response) (*ListRepositoryRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRepositoryRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunResponse parses an HTTP response from a GetRunWithResponse call
func ParseGetRunResponse(rsp *http.Response) (*GetRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRunHooksResponse parses an HTTP response from a ListRunHooksWithResponse call
func ParseListRunHooksResponse(rsp *http.Response) (*ListRunHooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListRunHooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HookRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRunHookOutputResponse parses an HTTP response from a GetRunHookOutputWithResponse call
func ParseGetRunHookOutputResponse(rsp *http.Response) (*GetRunHookOutputResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRunHookOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteBranchProtectionRuleResponse parses an HTTP response from a InternalDeleteBranchProtectionRuleWithResponse call
func ParseInternalDeleteBranchProtectionRuleResponse(rsp *http.Response) (*InternalDeleteBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetBranchProtectionRulesResponse parses an HTTP response from a InternalGetBranchProtectionRulesWithResponse call
func ParseInternalGetBranchProtectionRulesResponse(rsp *http.Response) (*InternalGetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalCreateBranchProtectionRuleResponse parses an HTTP response from a InternalCreateBranchProtectionRuleWithResponse call
func ParseInternalCreateBranchProtectionRuleResponse(rsp *http.Response) (*InternalCreateBranchProtectionRuleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalCreateBranchProtectionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchProtectionRulePreflightResponse parses an HTTP response from a CreateBranchProtectionRulePreflightWithResponse call
func ParseCreateBranchProtectionRulePreflightResponse(rsp *http.Response) (*CreateBranchProtectionRulePreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchProtectionRulePreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBranchesResponse parses an HTTP response from a ListBranchesWithResponse call
func ParseListBranchesResponse(rsp *http.Response) (*ListBranchesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBranchResponse parses an HTTP response from a CreateBranchWithResponse call
func ParseCreateBranchResponse(rsp *http.Response) (*CreateBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBranchResponse parses an HTTP response from a DeleteBranchWithResponse call
func ParseDeleteBranchResponse(rsp *http.Response) (*DeleteBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchResponse parses an HTTP response from a GetBranchWithResponse call
func ParseGetBranchResponse(rsp *http.Response) (*GetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetBranchResponse parses an HTTP response from a ResetBranchWithResponse call
func ParseResetBranchResponse(rsp *http.Response) (*ResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCherryPickResponse parses an HTTP response from a CherryPickWithResponse call
func ParseCherryPickResponse(rsp *http.Response) (*CherryPickResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CherryPickResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitResponse parses an HTTP response from a CommitWithResponse call
func ParseCommitResponse(rsp *http.Response) (*CommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffBranchResponse parses an HTTP response from a DiffBranchWithResponse call
func ParseDiffBranchResponse(rsp *http.Response) (*DiffBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHardResetBranchResponse parses an HTTP response from a HardResetBranchWithResponse call
func ParseHardResetBranchResponse(rsp *http.Response) (*HardResetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HardResetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportCancelResponse parses an HTTP response from a ImportCancelWithResponse call
func ParseImportCancelResponse(rsp *http.Response) (*ImportCancelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStatusResponse parses an HTTP response from a ImportStatusWithResponse call
func ParseImportStatusResponse(rsp *http.Response) (*ImportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseImportStartResponse parses an HTTP response from a ImportStartWithResponse call
func ParseImportStartResponse(rsp *http.Response) (*ImportStartResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ImportStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ImportCreationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectResponse parses an HTTP response from a DeleteObjectWithResponse call
func ParseDeleteObjectResponse(rsp *http.Response) (*DeleteObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectResponse parses an HTTP response from a UploadObjectWithResponse call
func ParseUploadObjectResponse(rsp *http.Response) (*UploadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStageObjectResponse parses an HTTP response from a StageObjectWithResponse call
func ParseStageObjectResponse(rsp *http.Response) (*StageObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StageObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCopyObjectResponse parses an HTTP response from a CopyObjectWithResponse call
func ParseCopyObjectResponse(rsp *http.Response) (*CopyObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CopyObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteObjectsResponse parses an HTTP response from a DeleteObjectsWithResponse call
func ParseDeleteObjectsResponse(rsp *http.Response) (*DeleteObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectErrorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadObjectPreflightResponse parses an HTTP response from a UploadObjectPreflightWithResponse call
func ParseUploadObjectPreflightResponse(rsp *http.Response) (*UploadObjectPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UploadObjectPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRevertBranchResponse parses an HTTP response from a RevertBranchWithResponse call
func ParseRevertBranchResponse(rsp *http.Response) (*RevertBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RevertBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPhysicalAddressResponse parses an HTTP response from a GetPhysicalAddressWithResponse call
func ParseGetPhysicalAddressResponse(rsp *http.Response) (*GetPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLinkPhysicalAddressResponse parses an HTTP response from a LinkPhysicalAddressWithResponse call
func ParseLinkPhysicalAddressResponse(rsp *http.Response) (*LinkPhysicalAddressResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LinkPhysicalAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePresignMultipartUploadResponse parses an HTTP response from a CreatePresignMultipartUploadWithResponse call
func ParseCreatePresignMultipartUploadResponse(rsp *http.Response) (*CreatePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreatePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PresignMultipartUpload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAbortPresignMultipartUploadResponse parses an HTTP response from a AbortPresignMultipartUploadWithResponse call
func ParseAbortPresignMultipartUploadResponse(rsp *http.Response) (*AbortPresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AbortPresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCompletePresignMultipartUploadResponse parses an HTTP response from a CompletePresignMultipartUploadWithResponse call
func ParseCompletePresignMultipartUploadResponse(rsp *http.Response) (*CompletePresignMultipartUploadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CompletePresignMultipartUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest StagingLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCommitRecordResponse parses an HTTP response from a CreateCommitRecordWithResponse call
func ParseCreateCommitRecordResponse(rsp *http.Response) (*CreateCommitRecordResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateCommitRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCommitResponse parses an HTTP response from a GetCommitWithResponse call
func ParseGetCommitResponse(rsp *http.Response) (*GetCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpStatusResponse parses an HTTP response from a DumpStatusWithResponse call
func ParseDumpStatusResponse(rsp *http.Response) (*DumpStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryDumpStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpSubmitResponse parses an HTTP response from a DumpSubmitWithResponse call
func ParseDumpSubmitResponse(rsp *http.Response) (*DumpSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionCommitsResponse parses an HTTP response from a PrepareGarbageCollectionCommitsWithResponse call
func ParsePrepareGarbageCollectionCommitsResponse(rsp *http.Response) (*PrepareGarbageCollectionCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GarbageCollectionPrepareResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePrepareGarbageCollectionUncommittedResponse parses an HTTP response from a PrepareGarbageCollectionUncommittedWithResponse call
func ParsePrepareGarbageCollectionUncommittedResponse(rsp *http.Response) (*PrepareGarbageCollectionUncommittedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PrepareGarbageCollectionUncommittedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PrepareGCUncommittedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalDeleteGarbageCollectionRulesResponse parses an HTTP response from a InternalDeleteGarbageCollectionRulesWithResponse call
func ParseInternalDeleteGarbageCollectionRulesResponse(rsp *http.Response) (*InternalDeleteGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalDeleteGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalGetGarbageCollectionRulesResponse parses an HTTP response from a InternalGetGarbageCollectionRulesWithResponse call
func ParseInternalGetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalGetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalGetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInternalSetGarbageCollectionRulesResponse parses an HTTP response from a InternalSetGarbageCollectionRulesWithResponse call
func ParseInternalSetGarbageCollectionRulesResponse(rsp *http.Response) (*InternalSetGarbageCollectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &InternalSetGarbageCollectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGarbageCollectionRulesPreflightResponse parses an HTTP response from a SetGarbageCollectionRulesPreflightWithResponse call
func ParseSetGarbageCollectionRulesPreflightResponse(rsp *http.Response) (*SetGarbageCollectionRulesPreflightResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGarbageCollectionRulesPreflightResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRepositoryMetadataResponse parses an HTTP response from a DeleteRepositoryMetadataWithResponse call
func ParseDeleteRepositoryMetadataResponse(rsp *http.Response) (*DeleteRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRepositoryMetadataResponse parses an HTTP response from a GetRepositoryMetadataWithResponse call
func ParseGetRepositoryMetadataResponse(rsp *http.Response) (*GetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetRepositoryMetadataResponse parses an HTTP response from a SetRepositoryMetadataWithResponse call
func ParseSetRepositoryMetadataResponse(rsp *http.Response) (*SetRepositoryMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetRepositoryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMetaRangeResponse parses an HTTP response from a GetMetaRangeWithResponse call
func ParseGetMetaRangeResponse(rsp *http.Response) (*GetMetaRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetaRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRangeResponse parses an HTTP response from a GetRangeWithResponse call
func ParseGetRangeResponse(rsp *http.Response) (*GetRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDumpRefsResponse parses an HTTP response from a DumpRefsWithResponse call
func ParseDumpRefsResponse(rsp *http.Response) (*DumpRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DumpRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RefsDump
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreRefsResponse parses an HTTP response from a RestoreRefsWithResponse call
func ParseRestoreRefsResponse(rsp *http.Response) (*RestoreRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSymlinkFileResponse parses an HTTP response from a CreateSymlinkFileWithResponse call
func ParseCreateSymlinkFileResponse(rsp *http.Response) (*CreateSymlinkFileResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateSymlinkFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StorageURI
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDiffRefsResponse parses an HTTP response from a DiffRefsWithResponse call
func ParseDiffRefsResponse(rsp *http.Response) (*DiffRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DiffRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DiffList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLogCommitsResponse parses an HTTP response from a LogCommitsWithResponse call
func ParseLogCommitsResponse(rsp *http.Response) (*LogCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &LogCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetObjectResponse parses an HTTP response from a GetObjectWithResponse call
func ParseGetObjectResponse(rsp *http.Response) (*GetObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 416:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON416 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHeadObjectResponse parses an HTTP response from a HeadObjectWithResponse call
func ParseHeadObjectResponse(rsp *http.Response) (*HeadObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &HeadObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseListObjectsResponse parses an HTTP response from a ListObjectsWithResponse call
func ParseListObjectsResponse(rsp *http.Response) (*ListObjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListObjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStatsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStatObjectResponse parses an HTTP response from a StatObjectWithResponse call
func ParseStatObjectResponse(rsp *http.Response) (*StatObjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &StatObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUnderlyingPropertiesResponse parses an HTTP response from a GetUnderlyingPropertiesWithResponse call
func ParseGetUnderlyingPropertiesResponse(rsp *http.Response) (*GetUnderlyingPropertiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUnderlyingPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UnderlyingObjectProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseFindMergeBaseResponse parses an HTTP response from a FindMergeBaseWithResponse call
func ParseFindMergeBaseResponse(rsp *http.Response) (*FindMergeBaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &FindMergeBaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindMergeBaseResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIntoBranchResponse parses an HTTP response from a MergeIntoBranchWithResponse call
func ParseMergeIntoBranchResponse(rsp *http.Response) (*MergeIntoBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &MergeIntoBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest MergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreStatusResponse parses an HTTP response from a RestoreStatusWithResponse call
func ParseRestoreStatusResponse(rsp *http.Response) (*RestoreStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryRestoreStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRestoreSubmitResponse parses an HTTP response from a RestoreSubmitWithResponse call
func ParseRestoreSubmitResponse(rsp *http.Response) (*RestoreSubmitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &RestoreSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TaskInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBranchProtectionRulesResponse parses an HTTP response from a GetBranchProtectionRulesWithResponse call
func ParseGetBranchProtectionRulesResponse(rsp *http.Response) (*GetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchProtectionRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetBranchProtectionRulesResponse parses an HTTP response from a SetBranchProtectionRulesWithResponse call
func ParseSetBranchProtectionRulesResponse(rsp *http.Response) (*SetBranchProtectionRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetBranchProtectionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGCRulesResponse parses an HTTP response from a DeleteGCRulesWithResponse call
func ParseDeleteGCRulesResponse(rsp *http.Response) (*DeleteGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGCRulesResponse parses an HTTP response from a GetGCRulesWithResponse call
func ParseGetGCRulesResponse(rsp *http.Response) (*GetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GarbageCollectionRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetGCRulesResponse parses an HTTP response from a SetGCRulesWithResponse call
func ParseSetGCRulesResponse(rsp *http.Response) (*SetGCRulesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetGCRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTagsResponse parses an HTTP response from a ListTagsWithResponse call
func ParseListTagsResponse(rsp *http.Response) (*ListTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTagResponse parses an HTTP response from a CreateTagWithResponse call
func ParseCreateTagResponse(rsp *http.Response) (*CreateTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &CreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagResponse parses an HTTP response from a DeleteTagWithResponse call
func ParseDeleteTagResponse(rsp *http.Response) (*DeleteTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagResponse parses an HTTP response from a GetTagWithResponse call
func ParseGetTagResponse(rsp *http.Response) (*GetTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ref
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupCommPrefsResponse parses an HTTP response from a SetupCommPrefsWithResponse call
func ParseSetupCommPrefsResponse(rsp *http.Response) (*SetupCommPrefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupCommPrefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSetupStateResponse parses an HTTP response from a GetSetupStateWithResponse call
func ParseGetSetupStateResponse(rsp *http.Response) (*GetSetupStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetSetupStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetupState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetupResponse parses an HTTP response from a SetupWithResponse call
func ParseSetupResponse(rsp *http.Response) (*SetupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CredentialsWithSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostStatsEventsResponse parses an HTTP response from a PostStatsEventsWithResponse call
func ParsePostStatsEventsResponse(rsp *http.Response) (*PostStatsEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostStatsEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsageReportSummaryResponse parses an HTTP response from a GetUsageReportSummaryWithResponse call
func ParseGetUsageReportSummaryResponse(rsp *http.Response) (*GetUsageReportSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetUsageReportSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstallationUsageReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/text) unsupported

	}

	return response, nil
}

// ParseGetCurrentUserResponse parses an HTTP response from a GetCurrentUserWithResponse call
func ParseGetCurrentUserResponse(rsp *http.Response) (*GetCurrentUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CurrentUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// chi-interface.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// list authentication capabilities supported
	// (GET /auth/capabilities)
	GetAuthCapabilities(w http.ResponseWriter, r *http.Request)
	// list groups
	// (GET /auth/groups)
	ListGroups(w http.ResponseWriter, r *http.Request, params ListGroupsParams)
	// create group
	// (POST /auth/groups)
	CreateGroup(w http.ResponseWriter, r *http.Request, body CreateGroupJSONRequestBody)
	// delete group
	// (DELETE /auth/groups/{groupId})
	DeleteGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get group
	// (GET /auth/groups/{groupId})
	GetGroup(w http.ResponseWriter, r *http.Request, groupId string)
	// get ACL of group
	// (GET /auth/groups/{groupId}/acl)
	GetGroupACL(w http.ResponseWriter, r *http.Request, groupId string)
	// set ACL of group
	// (POST /auth/groups/{groupId}/acl)
	SetGroupACL(w http.ResponseWriter, r *http.Request, body SetGroupACLJSONRequestBody, groupId string)
	// list group members
	// (GET /auth/groups/{groupId}/members)
	ListGroupMembers(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupMembersParams)
	// delete group membership
	// (DELETE /auth/groups/{groupId}/members/{userId})
	DeleteGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// add group membership
	// (PUT /auth/groups/{groupId}/members/{userId})
	AddGroupMembership(w http.ResponseWriter, r *http.Request, groupId string, userId string)
	// list group policies
	// (GET /auth/groups/{groupId}/policies)
	ListGroupPolicies(w http.ResponseWriter, r *http.Request, groupId string, params ListGroupPoliciesParams)
	// detach policy from group
	// (DELETE /auth/groups/{groupId}/policies/{policyId})
	DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// attach policy to group
	// (PUT /auth/groups/{groupId}/policies/{policyId})
	AttachPolicyToGroup(w http.ResponseWriter, r *http.Request, groupId string, policyId string)
	// perform a login
	// (POST /auth/login)
	Login(w http.ResponseWriter, r *http.Request, body LoginJSONRequestBody)
	// list policies
	// (GET /auth/policies)
	ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams)
	// create policy
	// (POST /auth/policies)
	CreatePolicy(w http.ResponseWriter, r *http.Request, body CreatePolicyJSONRequestBody)
	// delete policy
	// (DELETE /auth/policies/{policyId})
	DeletePolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// get policy
	// (GET /auth/policies/{policyId})
	GetPolicy(w http.ResponseWriter, r *http.Request, policyId string)
	// update policy
	// (PUT /auth/policies/{policyId})
	UpdatePolicy(w http.ResponseWriter, r *http.Request, body UpdatePolicyJSONRequestBody, policyId string)
	// list users
	// (GET /auth/users)
	ListUsers(w http.ResponseWriter, r *http.Request, params ListUsersParams)
	// create user
	// (POST /auth/users)
	CreateUser(w http.ResponseWriter, r *http.Request, body CreateUserJSONRequestBody)
	// delete user
	// (DELETE /auth/users/{userId})
	DeleteUser(w http.ResponseWriter, r *http.Request, userId string)
	// get user
	// (GET /auth/users/{userId})
	GetUser(w http.ResponseWriter, r *http.Request, userId string)
	// list user credentials
	// (GET /auth/users/{userId}/credentials)
	ListUserCredentials(w http.ResponseWriter, r *http.Request, userId string, params ListUserCredentialsParams)
	// create credentials
	// (POST /auth/users/{userId}/credentials)
	CreateCredentials(w http.ResponseWriter, r *http.Request, userId string)
	// delete credentials
	// (DELETE /auth/users/{userId}/credentials/{accessKeyId})
	DeleteCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// get credentials
	// (GET /auth/users/{userId}/credentials/{accessKeyId})
	GetCredentials(w http.ResponseWriter, r *http.Request, userId string, accessKeyId string)
	// list user groups
	// (GET /auth/users/{userId}/groups)
	ListUserGroups(w http.ResponseWriter, r *http.Request, userId string, params ListUserGroupsParams)
	// list user policies
	// (GET /auth/users/{userId}/policies)
	ListUserPolicies(w http.ResponseWriter, r *http.Request, userId string, params ListUserPoliciesParams)
	// detach policy from user
	// (DELETE /auth/users/{userId}/policies/{policyId})
	DetachPolicyFromUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)
	// attach policy to user
	// (PUT /auth/users/{userId}/policies/{policyId})
	AttachPolicyToUser(w http.ResponseWriter, r *http.Request, userId string, policyId string)

	// (GET /config)
	GetConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/garbage-collection)
	GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/storage)
	GetStorageConfig(w http.ResponseWriter, r *http.Request)

	// (GET /config/version)
	GetLakeFSVersion(w http.ResponseWriter, r *http.Request)

	// (GET /healthcheck)
	HealthCheck(w http.ResponseWriter, r *http.Request)
	// list repositories
	// (GET /repositories)
	ListRepositories(w http.ResponseWriter, r *http.Request, params ListRepositoriesParams)
	// create repository
	// (POST /repositories)
	CreateRepository(w http.ResponseWriter, r *http.Request, body CreateRepositoryJSONRequestBody, params CreateRepositoryParams)
	// delete repository
	// (DELETE /repositories/{repository})
	DeleteRepository(w http.ResponseWriter, r *http.Request, repository string, params DeleteRepositoryParams)
	// get repository
	// (GET /repositories/{repository})
	GetRepository(w http.ResponseWriter, r *http.Request, repository string)
	// list runs
	// (GET /repositories/{repository}/actions/runs)
	ListRepositoryRuns(w http.ResponseWriter, r *http.Request, repository string, params ListRepositoryRunsParams)
	// get a run
	// (GET /repositories/{repository}/actions/runs/{run_id})
	GetRun(w http.ResponseWriter, r *http.Request, repository string, runId string)
	// list run hooks
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks)
	ListRunHooks(w http.ResponseWriter, r *http.Request, repository string, runId string, params ListRunHooksParams)
	// get run hook output
	// (GET /repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output)
	GetRunHookOutput(w http.ResponseWriter, r *http.Request, repository string, runId string, hookRunId string)

	// (DELETE /repositories/{repository}/branch_protection)
	InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalDeleteBranchProtectionRuleJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/branch_protection)
	InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/branch_protection)
	InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request, body InternalCreateBranchProtectionRuleJSONRequestBody, repository string)

	// (GET /repositories/{repository}/branch_protection/set_allowed)
	CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request, repository string)
	// list branches
	// (GET /repositories/{repository}/branches)
	ListBranches(w http.ResponseWriter, r *http.Request, repository string, params ListBranchesParams)
	// create branch
	// (POST /repositories/{repository}/branches)
	CreateBranch(w http.ResponseWriter, r *http.Request, body CreateBranchJSONRequestBody, repository string)
	// delete branch
	// (DELETE /repositories/{repository}/branches/{branch})
	DeleteBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteBranchParams)
	// get branch
	// (GET /repositories/{repository}/branches/{branch})
	GetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string)
	// reset branch
	// (PUT /repositories/{repository}/branches/{branch})
	ResetBranch(w http.ResponseWriter, r *http.Request, body ResetBranchJSONRequestBody, repository string, branch string)
	// Replay the changes from the given commit on the branch
	// (POST /repositories/{repository}/branches/{branch}/cherry-pick)
	CherryPick(w http.ResponseWriter, r *http.Request, body CherryPickJSONRequestBody, repository string, branch string)
	// create commit
	// (POST /repositories/{repository}/branches/{branch}/commits)
	Commit(w http.ResponseWriter, r *http.Request, body CommitJSONRequestBody, repository string, branch string, params CommitParams)
	// diff branch
	// (GET /repositories/{repository}/branches/{branch}/diff)
	DiffBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params DiffBranchParams)
	// hard reset branch
	// (PUT /repositories/{repository}/branches/{branch}/hard_reset)
	HardResetBranch(w http.ResponseWriter, r *http.Request, repository string, branch string, params HardResetBranchParams)
	// cancel ongoing import
	// (DELETE /repositories/{repository}/branches/{branch}/import)
	ImportCancel(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportCancelParams)
	// get import status
	// (GET /repositories/{repository}/branches/{branch}/import)
	ImportStatus(w http.ResponseWriter, r *http.Request, repository string, branch string, params ImportStatusParams)
	// import data from object store
	// (POST /repositories/{repository}/branches/{branch}/import)
	ImportStart(w http.ResponseWriter, r *http.Request, body ImportStartJSONRequestBody, repository string, branch string)
	// delete object. Missing objects will not return a NotFound error.
	// (DELETE /repositories/{repository}/branches/{branch}/objects)
	DeleteObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params DeleteObjectParams)

	// (POST /repositories/{repository}/branches/{branch}/objects)
	UploadObject(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectParams)
	// stage an object's metadata for the given branch
	// (PUT /repositories/{repository}/branches/{branch}/objects)
	StageObject(w http.ResponseWriter, r *http.Request, body StageObjectJSONRequestBody, repository string, branch string, params StageObjectParams)
	// create a copy of an object
	// (POST /repositories/{repository}/branches/{branch}/objects/copy)
	CopyObject(w http.ResponseWriter, r *http.Request, body CopyObjectJSONRequestBody, repository string, branch string, params CopyObjectParams)
	// delete objects. Missing objects will not return a NotFound error.
	// (POST /repositories/{repository}/branches/{branch}/objects/delete)
	DeleteObjects(w http.ResponseWriter, r *http.Request, body DeleteObjectsJSONRequestBody, repository string, branch string, params DeleteObjectsParams)

	// (GET /repositories/{repository}/branches/{branch}/objects/stage_allowed)
	UploadObjectPreflight(w http.ResponseWriter, r *http.Request, repository string, branch string, params UploadObjectPreflightParams)
	// revert
	// (POST /repositories/{repository}/branches/{branch}/revert)
	RevertBranch(w http.ResponseWriter, r *http.Request, body RevertBranchJSONRequestBody, repository string, branch string)
	// generate an address to which the client can upload an object
	// (GET /repositories/{repository}/branches/{branch}/staging/backing)
	GetPhysicalAddress(w http.ResponseWriter, r *http.Request, repository string, branch string, params GetPhysicalAddressParams)
	// associate staging on this physical address with a path
	// (PUT /repositories/{repository}/branches/{branch}/staging/backing)
	LinkPhysicalAddress(w http.ResponseWriter, r *http.Request, body LinkPhysicalAddressJSONRequestBody, repository string, branch string, params LinkPhysicalAddressParams)
	// Initiate a multipart upload
	// (POST /repositories/{repository}/branches/{branch}/staging/pmpu)
	CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreatePresignMultipartUploadParams)
	// Abort a presign multipart upload
	// (DELETE /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request, body AbortPresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params AbortPresignMultipartUploadParams)
	// Complete a presign multipart upload request
	// (PUT /repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId})
	CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request, body CompletePresignMultipartUploadJSONRequestBody, repository string, branch string, uploadId string, params CompletePresignMultipartUploadParams)
	// create commit record
	// (POST /repositories/{repository}/commits)
	CreateCommitRecord(w http.ResponseWriter, r *http.Request, body CreateCommitRecordJSONRequestBody, repository string)
	// get commit
	// (GET /repositories/{repository}/commits/{commitId})
	GetCommit(w http.ResponseWriter, r *http.Request, repository string, commitId string)
	// Status of a repository dump task
	// (GET /repositories/{repository}/dump)
	DumpStatus(w http.ResponseWriter, r *http.Request, repository string, params DumpStatusParams)
	// Backup the repository metadata (tags, commits, branches) and save the backup to the object store.
	// (POST /repositories/{repository}/dump)
	DumpSubmit(w http.ResponseWriter, r *http.Request, repository string)
	// save lists of active commits for garbage collection
	// (POST /repositories/{repository}/gc/prepare_commits)
	PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request, repository string)
	// save repository uncommitted metadata for garbage collection
	// (POST /repositories/{repository}/gc/prepare_uncommited)
	PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request, body PrepareGarbageCollectionUncommittedJSONRequestBody, repository string)

	// (DELETE /repositories/{repository}/gc/rules)
	InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (GET /repositories/{repository}/gc/rules)
	InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (POST /repositories/{repository}/gc/rules)
	InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request, body InternalSetGarbageCollectionRulesJSONRequestBody, repository string)

	// (GET /repositories/{repository}/gc/rules/set_allowed)
	SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request, repository string)
	// delete repository metadata
	// (DELETE /repositories/{repository}/metadata)
	DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request, body DeleteRepositoryMetadataJSONRequestBody, repository string)
	// get repository metadata
	// (GET /repositories/{repository}/metadata)
	GetRepositoryMetadata(w http.ResponseWriter, r *http.Request, repository string)
	// set repository metadata
	// (POST /repositories/{repository}/metadata)
	SetRepositoryMetadata(w http.ResponseWriter, r *http.Request, body SetRepositoryMetadataJSONRequestBody, repository string)
	// return URI to a meta-range file
	// (GET /repositories/{repository}/metadata/meta_range/{meta_range})
	GetMetaRange(w http.ResponseWriter, r *http.Request, repository string, metaRange string)
	// return URI to a range file
	// (GET /repositories/{repository}/metadata/range/{range})
	GetRange(w http.ResponseWriter, r *http.Request, repository string, pRange string)
	// Dump repository refs (tags, commits, branches) to object store
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/dump)
	DumpRefs(w http.ResponseWriter, r *http.Request, repository string)
	// Restore repository refs (tags, commits, branches) from object store.
	// Deprecated: a new API will introduce long running operations
	// (PUT /repositories/{repository}/refs/restore)
	RestoreRefs(w http.ResponseWriter, r *http.Request, body RestoreRefsJSONRequestBody, repository string)
	// creates symlink files corresponding to the given directory
	// (POST /repositories/{repository}/refs/{branch}/symlink)
	CreateSymlinkFile(w http.ResponseWriter, r *http.Request, repository string, branch string, params CreateSymlinkFileParams)
	// diff references
	// (GET /repositories/{repository}/refs/{leftRef}/diff/{rightRef})
	DiffRefs(w http.ResponseWriter, r *http.Request, repository string, leftRef string, rightRef string, params DiffRefsParams)
	// get commit log from ref. If both objects and prefixes are empty, return all commits.
	// (GET /repositories/{repository}/refs/{ref}/commits)
	LogCommits(w http.ResponseWriter, r *http.Request, repository string, ref string, params LogCommitsParams)
	// get object content
	// (GET /repositories/{repository}/refs/{ref}/objects)
	GetObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetObjectParams)
	// check if object exists
	// (HEAD /repositories/{repository}/refs/{ref}/objects)
	HeadObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params HeadObjectParams)
	// list objects under a given prefix
	// (GET /repositories/{repository}/refs/{ref}/objects/ls)
	ListObjects(w http.ResponseWriter, r *http.Request, repository string, ref string, params ListObjectsParams)
	// get object metadata
	// (GET /repositories/{repository}/refs/{ref}/objects/stat)
	StatObject(w http.ResponseWriter, r *http.Request, repository string, ref string, params StatObjectParams)
	// get object properties on underlying storage
	// (GET /repositories/{repository}/refs/{ref}/objects/underlyingProperties)
	GetUnderlyingProperties(w http.ResponseWriter, r *http.Request, repository string, ref string, params GetUnderlyingPropertiesParams)
	// find the merge base for 2 references
	// (GET /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	FindMergeBase(w http.ResponseWriter, r *http.Request, repository string, sourceRef string, destinationBranch string)
	// merge references
	// (POST /repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch})
	MergeIntoBranch(w http.ResponseWriter, r *http.Request, body MergeIntoBranchJSONRequestBody, repository string, sourceRef string, destinationBranch string)
	// Status of a restore request
	// (GET /repositories/{repository}/restore)
	RestoreStatus(w http.ResponseWriter, r *http.Request, repository string, params RestoreStatusParams)
	// Restore repository from a dump in the object store
	// (POST /repositories/{repository}/restore)
	RestoreSubmit(w http.ResponseWriter, r *http.Request, body RestoreSubmitJSONRequestBody, repository string)
	// get branch protection rules
	// (GET /repositories/{repository}/settings/branch_protection)
	GetBranchProtectionRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/branch_protection)
	SetBranchProtectionRules(w http.ResponseWriter, r *http.Request, body SetBranchProtectionRulesJSONRequestBody, repository string, params SetBranchProtectionRulesParams)

	// (DELETE /repositories/{repository}/settings/gc_rules)
	DeleteGCRules(w http.ResponseWriter, r *http.Request, repository string)
	// get repository GC rules
	// (GET /repositories/{repository}/settings/gc_rules)
	GetGCRules(w http.ResponseWriter, r *http.Request, repository string)

	// (PUT /repositories/{repository}/settings/gc_rules)
	SetGCRules(w http.ResponseWriter, r *http.Request, body SetGCRulesJSONRequestBody, repository string)
	// list tags
	// (GET /repositories/{repository}/tags)
	ListTags(w http.ResponseWriter, r *http.Request, repository string, params ListTagsParams)
	// create tag
	// (POST /repositories/{repository}/tags)
	CreateTag(w http.ResponseWriter, r *http.Request, body CreateTagJSONRequestBody, repository string)
	// delete tag
	// (DELETE /repositories/{repository}/tags/{tag})
	DeleteTag(w http.ResponseWriter, r *http.Request, repository string, tag string, params DeleteTagParams)
	// get tag
	// (GET /repositories/{repository}/tags/{tag})
	GetTag(w http.ResponseWriter, r *http.Request, repository string, tag string)
	// setup communications preferences
	// (POST /setup_comm_prefs)
	SetupCommPrefs(w http.ResponseWriter, r *http.Request, body SetupCommPrefsJSONRequestBody)
	// check if the lakeFS installation is already set up
	// (GET /setup_lakefs)
	GetSetupState(w http.ResponseWriter, r *http.Request)
	// setup lakeFS and create a first user
	// (POST /setup_lakefs)
	Setup(w http.ResponseWriter, r *http.Request, body SetupJSONRequestBody)
	// post stats events, this endpoint is meant for internal use only
	// (POST /statistics)
	PostStatsEvents(w http.ResponseWriter, r *http.Request, body PostStatsEventsJSONRequestBody)
	// get usage report summary
	// (GET /usage-report/summary)
	GetUsageReportSummary(w http.ResponseWriter, r *http.Request)
	// get current user
	// (GET /user)
	GetCurrentUser(w http.ResponseWriter, r *http.Request)
}

// chi-middleware.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAuthCapabilities operation middleware
func (siw *ServerInterfaceWrapper) GetAuthCapabilities(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAuthCapabilities(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroups operation middleware
func (siw *ServerInterfaceWrapper) ListGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroups(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateGroup operation middleware
func (siw *ServerInterfaceWrapper) CreateGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body CreateGroupJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateGroup' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateGroup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroup operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroup operation middleware
func (siw *ServerInterfaceWrapper) GetGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroup(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) GetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGroupACL(w, r, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGroupACL operation middleware
func (siw *ServerInterfaceWrapper) SetGroupACL(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetGroupACLJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGroupACL' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGroupACL(w, r, body, groupId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupMembers operation middleware
func (siw *ServerInterfaceWrapper) ListGroupMembers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupMembersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupMembers(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddGroupMembership operation middleware
func (siw *ServerInterfaceWrapper) AddGroupMembership(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddGroupMembership(w, r, groupId, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListGroupPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListGroupPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListGroupPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListGroupPolicies(w, r, groupId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromGroup operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToGroup operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToGroup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "groupId" -------------
	var groupId string

	err = runtime.BindStyledParameter("simple", false, "groupId", chi.URLParam(r, "groupId"), &groupId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter groupId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToGroup(w, r, groupId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body LoginJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Login' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Login(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPolicies(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePolicy operation middleware
func (siw *ServerInterfaceWrapper) CreatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body CreatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePolicy(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeletePolicy operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPolicy(w, r, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UpdatePolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body UpdatePolicyJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'UpdatePolicy' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicy(w, r, body, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUsers operation middleware
func (siw *ServerInterfaceWrapper) ListUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUsers(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body CreateUserJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateUser' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateUser(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUser(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserCredentials operation middleware
func (siw *ServerInterfaceWrapper) ListUserCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserCredentialsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserCredentials(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCredentials operation middleware
func (siw *ServerInterfaceWrapper) CreateCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCredentials(w, r, userId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteCredentials operation middleware
func (siw *ServerInterfaceWrapper) DeleteCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCredentials operation middleware
func (siw *ServerInterfaceWrapper) GetCredentials(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "accessKeyId" -------------
	var accessKeyId string

	err = runtime.BindStyledParameter("simple", false, "accessKeyId", chi.URLParam(r, "accessKeyId"), &accessKeyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accessKeyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCredentials(w, r, userId, accessKeyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserGroups operation middleware
func (siw *ServerInterfaceWrapper) ListUserGroups(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserGroupsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserGroups(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListUserPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListUserPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUserPoliciesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "effective" -------------
	if paramValue := r.URL.Query().Get("effective"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "effective", r.URL.Query(), &params.Effective)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter effective: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListUserPolicies(w, r, userId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DetachPolicyFromUser operation middleware
func (siw *ServerInterfaceWrapper) DetachPolicyFromUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DetachPolicyFromUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AttachPolicyToUser operation middleware
func (siw *ServerInterfaceWrapper) AttachPolicyToUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "userId" -------------
	var userId string

	err = runtime.BindStyledParameter("simple", false, "userId", chi.URLParam(r, "userId"), &userId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter userId: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "policyId" -------------
	var policyId string

	err = runtime.BindStyledParameter("simple", false, "policyId", chi.URLParam(r, "policyId"), &policyId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter policyId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AttachPolicyToUser(w, r, userId, policyId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConfig operation middleware
func (siw *ServerInterfaceWrapper) GetConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGarbageCollectionConfig operation middleware
func (siw *ServerInterfaceWrapper) GetGarbageCollectionConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGarbageCollectionConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetStorageConfig operation middleware
func (siw *ServerInterfaceWrapper) GetStorageConfig(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStorageConfig(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetLakeFSVersion operation middleware
func (siw *ServerInterfaceWrapper) GetLakeFSVersion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLakeFSVersion(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HealthCheck operation middleware
func (siw *ServerInterfaceWrapper) HealthCheck(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HealthCheck(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositories operation middleware
func (siw *ServerInterfaceWrapper) ListRepositories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoriesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositories(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateRepository operation middleware
func (siw *ServerInterfaceWrapper) CreateRepository(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateRepositoryJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateRepository' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateRepositoryParams

	// ------------- Optional query parameter "bare" -------------
	if paramValue := r.URL.Query().Get("bare"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "bare", r.URL.Query(), &params.Bare)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter bare: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateRepository(w, r, body, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepository operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepository(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteRepositoryParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepository(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepository operation middleware
func (siw *ServerInterfaceWrapper) GetRepository(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepository(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRepositoryRuns operation middleware
func (siw *ServerInterfaceWrapper) ListRepositoryRuns(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRepositoryRunsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "branch" -------------
	if paramValue := r.URL.Query().Get("branch"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "branch", r.URL.Query(), &params.Branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "commit" -------------
	if paramValue := r.URL.Query().Get("commit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "commit", r.URL.Query(), &params.Commit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRepositoryRuns(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRun operation middleware
func (siw *ServerInterfaceWrapper) GetRun(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRun(w, r, repository, runId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListRunHooks operation middleware
func (siw *ServerInterfaceWrapper) ListRunHooks(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRunHooksParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListRunHooks(w, r, repository, runId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRunHookOutput operation middleware
func (siw *ServerInterfaceWrapper) GetRunHookOutput(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "run_id" -------------
	var runId string

	err = runtime.BindStyledParameter("simple", false, "run_id", chi.URLParam(r, "run_id"), &runId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter run_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "hook_run_id" -------------
	var hookRunId string

	err = runtime.BindStyledParameter("simple", false, "hook_run_id", chi.URLParam(r, "hook_run_id"), &hookRunId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter hook_run_id: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRunHookOutput(w, r, repository, runId, hookRunId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body InternalDeleteBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalDeleteBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalCreateBranchProtectionRule operation middleware
func (siw *ServerInterfaceWrapper) InternalCreateBranchProtectionRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body InternalCreateBranchProtectionRuleJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalCreateBranchProtectionRule' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalCreateBranchProtectionRule(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranchProtectionRulePreflight operation middleware
func (siw *ServerInterfaceWrapper) CreateBranchProtectionRulePreflight(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranchProtectionRulePreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListBranches operation middleware
func (siw *ServerInterfaceWrapper) ListBranches(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBranchesParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListBranches(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateBranch operation middleware
func (siw *ServerInterfaceWrapper) CreateBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateBranch(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteBranch operation middleware
func (siw *ServerInterfaceWrapper) DeleteBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteBranchParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranch operation middleware
func (siw *ServerInterfaceWrapper) GetBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranch(w, r, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ResetBranch operation middleware
func (siw *ServerInterfaceWrapper) ResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body ResetBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ResetBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResetBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CherryPick operation middleware
func (siw *ServerInterfaceWrapper) CherryPick(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CherryPickJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CherryPick' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CherryPick(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Commit operation middleware
func (siw *ServerInterfaceWrapper) Commit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CommitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Commit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommitParams

	// ------------- Optional query parameter "source_metarange" -------------
	if paramValue := r.URL.Query().Get("source_metarange"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "source_metarange", r.URL.Query(), &params.SourceMetarange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter source_metarange: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Commit(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffBranch operation middleware
func (siw *ServerInterfaceWrapper) DiffBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffBranchParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HardResetBranch operation middleware
func (siw *ServerInterfaceWrapper) HardResetBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HardResetBranchParams

	// ------------- Required query parameter "ref" -------------
	if paramValue := r.URL.Query().Get("ref"); paramValue != "" {

	} else {
		http.Error(w, "Query argument ref is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "ref", r.URL.Query(), &params.Ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HardResetBranch(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportCancel operation middleware
func (siw *ServerInterfaceWrapper) ImportCancel(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportCancelParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportCancel(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStatus operation middleware
func (siw *ServerInterfaceWrapper) ImportStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ImportStatusParams

	// ------------- Required query parameter "id" -------------
	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStatus(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ImportStart operation middleware
func (siw *ServerInterfaceWrapper) ImportStart(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body ImportStartJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'ImportStart' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ImportStart(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObject operation middleware
func (siw *ServerInterfaceWrapper) DeleteObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObject operation middleware
func (siw *ServerInterfaceWrapper) UploadObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "storageClass" -------------
	if paramValue := r.URL.Query().Get("storageClass"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "storageClass", r.URL.Query(), &params.StorageClass)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter storageClass: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObject(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StageObject operation middleware
func (siw *ServerInterfaceWrapper) StageObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body StageObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'StageObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StageObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StageObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CopyObject operation middleware
func (siw *ServerInterfaceWrapper) CopyObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CopyObjectJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CopyObject' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CopyObjectParams

	// ------------- Required query parameter "dest_path" -------------
	if paramValue := r.URL.Query().Get("dest_path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument dest_path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "dest_path", r.URL.Query(), &params.DestPath)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter dest_path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CopyObject(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteObjects operation middleware
func (siw *ServerInterfaceWrapper) DeleteObjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body DeleteObjectsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteObjects' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteObjectsParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteObjects(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// UploadObjectPreflight operation middleware
func (siw *ServerInterfaceWrapper) UploadObjectPreflight(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params UploadObjectPreflightParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadObjectPreflight(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RevertBranch operation middleware
func (siw *ServerInterfaceWrapper) RevertBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body RevertBranchJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RevertBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RevertBranch(w, r, body, repository, branch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) GetPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPhysicalAddress(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LinkPhysicalAddress operation middleware
func (siw *ServerInterfaceWrapper) LinkPhysicalAddress(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body LinkPhysicalAddressJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'LinkPhysicalAddress' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LinkPhysicalAddressParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch IfNoneMatch
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-None-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-None-Match", valueList[0], &IfNoneMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LinkPhysicalAddress(w, r, body, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreatePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CreatePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "parts" -------------
	if paramValue := r.URL.Query().Get("parts"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "parts", r.URL.Query(), &params.Parts)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter parts: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreatePresignMultipartUpload(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AbortPresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) AbortPresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body AbortPresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'AbortPresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AbortPresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AbortPresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CompletePresignMultipartUpload operation middleware
func (siw *ServerInterfaceWrapper) CompletePresignMultipartUpload(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CompletePresignMultipartUploadJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CompletePresignMultipartUpload' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "uploadId" -------------
	var uploadId string

	err = runtime.BindStyledParameter("simple", false, "uploadId", chi.URLParam(r, "uploadId"), &uploadId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter uploadId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CompletePresignMultipartUploadParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CompletePresignMultipartUpload(w, r, body, repository, branch, uploadId, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateCommitRecord operation middleware
func (siw *ServerInterfaceWrapper) CreateCommitRecord(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateCommitRecordJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateCommitRecord' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateCommitRecord(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCommit operation middleware
func (siw *ServerInterfaceWrapper) GetCommit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "commitId" -------------
	var commitId string

	err = runtime.BindStyledParameter("simple", false, "commitId", chi.URLParam(r, "commitId"), &commitId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter commitId: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCommit(w, r, repository, commitId)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpStatus operation middleware
func (siw *ServerInterfaceWrapper) DumpStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DumpStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpSubmit operation middleware
func (siw *ServerInterfaceWrapper) DumpSubmit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpSubmit(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionCommits operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionCommits(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionCommits(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PrepareGarbageCollectionUncommitted operation middleware
func (siw *ServerInterfaceWrapper) PrepareGarbageCollectionUncommitted(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body PrepareGarbageCollectionUncommittedJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PrepareGarbageCollectionUncommitted' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PrepareGarbageCollectionUncommitted(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalDeleteGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalDeleteGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalDeleteGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalGetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalGetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalGetGarbageCollectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// InternalSetGarbageCollectionRules operation middleware
func (siw *ServerInterfaceWrapper) InternalSetGarbageCollectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body InternalSetGarbageCollectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'InternalSetGarbageCollectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InternalSetGarbageCollectionRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGarbageCollectionRulesPreflight operation middleware
func (siw *ServerInterfaceWrapper) SetGarbageCollectionRulesPreflight(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGarbageCollectionRulesPreflight(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) DeleteRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body DeleteRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'DeleteRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRepositoryMetadata(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetRepositoryMetadata operation middleware
func (siw *ServerInterfaceWrapper) SetRepositoryMetadata(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetRepositoryMetadataJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetRepositoryMetadata' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetRepositoryMetadata(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetMetaRange operation middleware
func (siw *ServerInterfaceWrapper) GetMetaRange(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "meta_range" -------------
	var metaRange string

	err = runtime.BindStyledParameter("simple", false, "meta_range", chi.URLParam(r, "meta_range"), &metaRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter meta_range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMetaRange(w, r, repository, metaRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRange operation middleware
func (siw *ServerInterfaceWrapper) GetRange(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "range" -------------
	var pRange string

	err = runtime.BindStyledParameter("simple", false, "range", chi.URLParam(r, "range"), &pRange)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter range: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRange(w, r, repository, pRange)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DumpRefs operation middleware
func (siw *ServerInterfaceWrapper) DumpRefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DumpRefs(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreRefs operation middleware
func (siw *ServerInterfaceWrapper) RestoreRefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body RestoreRefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreRefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreRefs(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateSymlinkFile operation middleware
func (siw *ServerInterfaceWrapper) CreateSymlinkFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "branch" -------------
	var branch string

	err = runtime.BindStyledParameter("simple", false, "branch", chi.URLParam(r, "branch"), &branch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter branch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateSymlinkFileParams

	// ------------- Optional query parameter "location" -------------
	if paramValue := r.URL.Query().Get("location"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "location", r.URL.Query(), &params.Location)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter location: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSymlinkFile(w, r, repository, branch, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DiffRefs operation middleware
func (siw *ServerInterfaceWrapper) DiffRefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "leftRef" -------------
	var leftRef string

	err = runtime.BindStyledParameter("simple", false, "leftRef", chi.URLParam(r, "leftRef"), &leftRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter leftRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "rightRef" -------------
	var rightRef string

	err = runtime.BindStyledParameter("simple", false, "rightRef", chi.URLParam(r, "rightRef"), &rightRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter rightRef: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DiffRefsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "type" -------------
	if paramValue := r.URL.Query().Get("type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter type: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DiffRefs(w, r, repository, leftRef, rightRef, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// LogCommits operation middleware
func (siw *ServerInterfaceWrapper) LogCommits(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params LogCommitsParams

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "objects" -------------
	if paramValue := r.URL.Query().Get("objects"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "objects", r.URL.Query(), &params.Objects)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter objects: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefixes" -------------
	if paramValue := r.URL.Query().Get("prefixes"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefixes", r.URL.Query(), &params.Prefixes)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefixes: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "first_parent" -------------
	if paramValue := r.URL.Query().Get("first_parent"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "first_parent", r.URL.Query(), &params.FirstParent)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter first_parent: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "since" -------------
	if paramValue := r.URL.Query().Get("since"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "since", r.URL.Query(), &params.Since)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter since: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "stop_at" -------------
	if paramValue := r.URL.Query().Get("stop_at"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "stop_at", r.URL.Query(), &params.StopAt)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter stop_at: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogCommits(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetObject operation middleware
func (siw *ServerInterfaceWrapper) GetObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// HeadObject operation middleware
func (siw *ServerInterfaceWrapper) HeadObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "Range" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Range")]; found {
		var Range string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for Range, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "Range", valueList[0], &Range)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter Range: %s", err), http.StatusBadRequest)
			return
		}

		params.Range = &Range

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListObjects operation middleware
func (siw *ServerInterfaceWrapper) ListObjects(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListObjectsParams

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "delimiter" -------------
	if paramValue := r.URL.Query().Get("delimiter"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "delimiter", r.URL.Query(), &params.Delimiter)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter delimiter: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListObjects(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// StatObject operation middleware
func (siw *ServerInterfaceWrapper) StatObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StatObjectParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "user_metadata" -------------
	if paramValue := r.URL.Query().Get("user_metadata"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "user_metadata", r.URL.Query(), &params.UserMetadata)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter user_metadata: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "presign" -------------
	if paramValue := r.URL.Query().Get("presign"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "presign", r.URL.Query(), &params.Presign)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter presign: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.StatObject(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUnderlyingProperties operation middleware
func (siw *ServerInterfaceWrapper) GetUnderlyingProperties(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "ref" -------------
	var ref string

	err = runtime.BindStyledParameter("simple", false, "ref", chi.URLParam(r, "ref"), &ref)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter ref: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUnderlyingPropertiesParams

	// ------------- Required query parameter "path" -------------
	if paramValue := r.URL.Query().Get("path"); paramValue != "" {

	} else {
		http.Error(w, "Query argument path is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "path", r.URL.Query(), &params.Path)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter path: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUnderlyingProperties(w, r, repository, ref, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// FindMergeBase operation middleware
func (siw *ServerInterfaceWrapper) FindMergeBase(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindMergeBase(w, r, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// MergeIntoBranch operation middleware
func (siw *ServerInterfaceWrapper) MergeIntoBranch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body MergeIntoBranchJSONRequestBody
	parseBody := r.ContentLength != 0
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'MergeIntoBranch' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "sourceRef" -------------
	var sourceRef string

	err = runtime.BindStyledParameter("simple", false, "sourceRef", chi.URLParam(r, "sourceRef"), &sourceRef)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter sourceRef: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "destinationBranch" -------------
	var destinationBranch string

	err = runtime.BindStyledParameter("simple", false, "destinationBranch", chi.URLParam(r, "destinationBranch"), &destinationBranch)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter destinationBranch: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MergeIntoBranch(w, r, body, repository, sourceRef, destinationBranch)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreStatus operation middleware
func (siw *ServerInterfaceWrapper) RestoreStatus(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RestoreStatusParams

	// ------------- Required query parameter "task_id" -------------
	if paramValue := r.URL.Query().Get("task_id"); paramValue != "" {

	} else {
		http.Error(w, "Query argument task_id is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "task_id", r.URL.Query(), &params.TaskId)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter task_id: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreStatus(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// RestoreSubmit operation middleware
func (siw *ServerInterfaceWrapper) RestoreSubmit(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body RestoreSubmitJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'RestoreSubmit' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RestoreSubmit(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) GetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBranchProtectionRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetBranchProtectionRules operation middleware
func (siw *ServerInterfaceWrapper) SetBranchProtectionRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetBranchProtectionRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetBranchProtectionRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetBranchProtectionRulesParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			http.Error(w, fmt.Sprintf("Expected one value for If-Match, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameter("simple", false, "If-Match", valueList[0], &IfMatch)
		if err != nil {
			http.Error(w, fmt.Sprintf("Invalid format for parameter If-Match: %s", err), http.StatusBadRequest)
			return
		}

		params.IfMatch = &IfMatch

	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetBranchProtectionRules(w, r, body, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteGCRules operation middleware
func (siw *ServerInterfaceWrapper) DeleteGCRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetGCRules operation middleware
func (siw *ServerInterfaceWrapper) GetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGCRules(w, r, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetGCRules operation middleware
func (siw *ServerInterfaceWrapper) SetGCRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body SetGCRulesJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetGCRules' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetGCRules(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListTags operation middleware
func (siw *ServerInterfaceWrapper) ListTags(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTagsParams

	// ------------- Optional query parameter "prefix" -------------
	if paramValue := r.URL.Query().Get("prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter prefix: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "after" -------------
	if paramValue := r.URL.Query().Get("after"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after", r.URL.Query(), &params.After)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter after: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "amount" -------------
	if paramValue := r.URL.Query().Get("amount"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "amount", r.URL.Query(), &params.Amount)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter amount: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTags(w, r, repository, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateTag operation middleware
func (siw *ServerInterfaceWrapper) CreateTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Body parse -------------
	var body CreateTagJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'CreateTag' as JSON", http.StatusBadRequest)
			return
		}
	}

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateTag(w, r, body, repository)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteTag operation middleware
func (siw *ServerInterfaceWrapper) DeleteTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTagParams

	// ------------- Optional query parameter "force" -------------
	if paramValue := r.URL.Query().Get("force"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "force", r.URL.Query(), &params.Force)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter force: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteTag(w, r, repository, tag, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetTag operation middleware
func (siw *ServerInterfaceWrapper) GetTag(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "repository" -------------
	var repository string

	err = runtime.BindStyledParameter("simple", false, "repository", chi.URLParam(r, "repository"), &repository)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter repository: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "tag" -------------
	var tag string

	err = runtime.BindStyledParameter("simple", false, "tag", chi.URLParam(r, "tag"), &tag)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter tag: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTag(w, r, repository, tag)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetupCommPrefs operation middleware
func (siw *ServerInterfaceWrapper) SetupCommPrefs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body SetupCommPrefsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'SetupCommPrefs' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetupCommPrefs(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetSetupState operation middleware
func (siw *ServerInterfaceWrapper) GetSetupState(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSetupState(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Setup operation middleware
func (siw *ServerInterfaceWrapper) Setup(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body SetupJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'Setup' as JSON", http.StatusBadRequest)
			return
		}
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Setup(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// PostStatsEvents operation middleware
func (siw *ServerInterfaceWrapper) PostStatsEvents(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Body parse -------------
	var body PostStatsEventsJSONRequestBody
	parseBody := true
	if parseBody {
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, "Error unmarshalling body 'PostStatsEvents' as JSON", http.StatusBadRequest)
			return
		}
	}

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostStatsEvents(w, r, body)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetUsageReportSummary operation middleware
func (siw *ServerInterfaceWrapper) GetUsageReportSummary(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetUsageReportSummary(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, Jwt_tokenScopes, []string{""})

	ctx = context.WithValue(ctx, Basic_authScopes, []string{""})

	ctx = context.WithValue(ctx, Cookie_authScopes, []string{""})

	ctx = context.WithValue(ctx, Oidc_authScopes, []string{""})

	ctx = context.WithValue(ctx, Saml_authScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCurrentUser(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/capabilities", wrapper.GetAuthCapabilities)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups", wrapper.ListGroups)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups", wrapper.CreateGroup)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}", wrapper.DeleteGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}", wrapper.GetGroup)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.GetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/groups/{groupId}/acl", wrapper.SetGroupACL)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/members", wrapper.ListGroupMembers)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.DeleteGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/members/{userId}", wrapper.AddGroupMembership)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/groups/{groupId}/policies", wrapper.ListGroupPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.DetachPolicyFromGroup)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/groups/{groupId}/policies/{policyId}", wrapper.AttachPolicyToGroup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/login", wrapper.Login)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies", wrapper.ListPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/policies", wrapper.CreatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/policies/{policyId}", wrapper.DeletePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/policies/{policyId}", wrapper.GetPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/policies/{policyId}", wrapper.UpdatePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users", wrapper.ListUsers)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users", wrapper.CreateUser)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}", wrapper.DeleteUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}", wrapper.GetUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.ListUserCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/auth/users/{userId}/credentials", wrapper.CreateCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.DeleteCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/credentials/{accessKeyId}", wrapper.GetCredentials)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/groups", wrapper.ListUserGroups)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/auth/users/{userId}/policies", wrapper.ListUserPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.DetachPolicyFromUser)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/auth/users/{userId}/policies/{policyId}", wrapper.AttachPolicyToUser)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config", wrapper.GetConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/garbage-collection", wrapper.GetGarbageCollectionConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/storage", wrapper.GetStorageConfig)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/config/version", wrapper.GetLakeFSVersion)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/healthcheck", wrapper.HealthCheck)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories", wrapper.ListRepositories)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories", wrapper.CreateRepository)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}", wrapper.DeleteRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}", wrapper.GetRepository)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs", wrapper.ListRepositoryRuns)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}", wrapper.GetRun)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks", wrapper.ListRunHooks)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/actions/runs/{run_id}/hooks/{hook_run_id}/output", wrapper.GetRunHookOutput)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalDeleteBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalGetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branch_protection", wrapper.InternalCreateBranchProtectionRule)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branch_protection/set_allowed", wrapper.CreateBranchProtectionRulePreflight)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches", wrapper.ListBranches)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches", wrapper.CreateBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.DeleteBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.GetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}", wrapper.ResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/cherry-pick", wrapper.CherryPick)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/commits", wrapper.Commit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/diff", wrapper.DiffBranch)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/hard_reset", wrapper.HardResetBranch)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportCancel)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/import", wrapper.ImportStart)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.DeleteObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.UploadObject)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects", wrapper.StageObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/copy", wrapper.CopyObject)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/delete", wrapper.DeleteObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/objects/stage_allowed", wrapper.UploadObjectPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/revert", wrapper.RevertBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.GetPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/backing", wrapper.LinkPhysicalAddress)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu", wrapper.CreatePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.AbortPresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/branches/{branch}/staging/pmpu/{uploadId}", wrapper.CompletePresignMultipartUpload)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/commits", wrapper.CreateCommitRecord)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/commits/{commitId}", wrapper.GetCommit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/dump", wrapper.DumpSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_commits", wrapper.PrepareGarbageCollectionCommits)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/prepare_uncommited", wrapper.PrepareGarbageCollectionUncommitted)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalDeleteGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalGetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/gc/rules", wrapper.InternalSetGarbageCollectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/gc/rules/set_allowed", wrapper.SetGarbageCollectionRulesPreflight)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/metadata", wrapper.DeleteRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata", wrapper.GetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/metadata", wrapper.SetRepositoryMetadata)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/meta_range/{meta_range}", wrapper.GetMetaRange)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/metadata/range/{range}", wrapper.GetRange)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/dump", wrapper.DumpRefs)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/refs/restore", wrapper.RestoreRefs)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{branch}/symlink", wrapper.CreateSymlinkFile)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{leftRef}/diff/{rightRef}", wrapper.DiffRefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/commits", wrapper.LogCommits)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.GetObject)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects", wrapper.HeadObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/ls", wrapper.ListObjects)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/stat", wrapper.StatObject)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{ref}/objects/underlyingProperties", wrapper.GetUnderlyingProperties)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.FindMergeBase)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/refs/{sourceRef}/merge/{destinationBranch}", wrapper.MergeIntoBranch)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/restore", wrapper.RestoreSubmit)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.GetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/branch_protection", wrapper.SetBranchProtectionRules)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.DeleteGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.GetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/repositories/{repository}/settings/gc_rules", wrapper.SetGCRules)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags", wrapper.ListTags)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/repositories/{repository}/tags", wrapper.CreateTag)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.DeleteTag)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/repositories/{repository}/tags/{tag}", wrapper.GetTag)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_comm_prefs", wrapper.SetupCommPrefs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/setup_lakefs", wrapper.GetSetupState)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/setup_lakefs", wrapper.Setup)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/statistics", wrapper.PostStatsEvents)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/usage-report/summary", wrapper.GetUsageReportSummary)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/user", wrapper.GetCurrentUser)
	})

	return r
}

// inline.tmpl based on https://github.com/deepmap/oapi-codegen/tree/master/pkg/codegen/templates

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9a3PbOJYA+ldQulPVSV9ZcpLenjvZmppKnEd7O0m77Hh7t9pZFUQeSRiTABsAbWs8",
	"+e+38OJDBEjKlmTH8ZfuWCTxODg478f1IGJpxihQKQYvrwcZ5jgFCVz/dTj7xCh8xDJaqD9jEBEnmSSM",
	"Dl4OTkAiydDZ4MezgfoHliwlEU6SJcJJwi6RXADKs4ThGDGaLBGZ6Z/OYYkWWCDKEJv+EyKJliBH6De5",
	"AI4ucJKDQJgDokwikWcZ4xLi0WA4gCucZgkMXg5+HAwHRK1hATgGPhgOKE7Vg8PZnlrxnlnycCCiBaRY",
	"rV0uM/WCkJzQ+eDr1+HgCM8JxWozr2YSeHODHGTOKSISUoGwegfJBRFmjW4Ff+bAl+UC9Gv9J05ZTmVz",
	"5gW7RCmmSzu3ZMisJTSpGaY6awwznCdy8PLZ/v5wkOIrkuap/kv9Saj5c+/Z0K2PUAlz4CsLfAMJSYkX",
	"OrF7hHIBsVrjnLM8QxFLU0ZRxmFGrkCg6TKw6mKA3uA60mN2HJSdOEaXRC66D8y83rqEr8MBB5ExKkDf",
	"itc4PoY/cxD65CJGJZhDxFmWkEgvdfxPoZZ2XRn2Lxxmg5eD/2dc3rixeSrGbzln3ExV39prHCM32dfh",
	"4IDRWUKiHUx8DILlPALkphTodwXQz5jPQa/lHeNTEsdAt7+Ycqqvw8EnJt+xnMY7hMEnJpGZszL/b/wT",
	"e3XwYbPLMEN61vJeXy5FE2dq8iFi3F44/Tea5tJRVT3CcHDEIWI0JmqAd5gksAOIVedEdtKvw8EJ8Avg",
	"5qutr+GQSuAUJ8jMiuyLw8EpxblcME7+tQtQ1Gb7Ohz8N05IrGfYERzKCR0Ivjoqp8mYxd2Mswy4JIa2",
	"ZcBTIgQxK1g53OIZSuACEk3zyQUYIvvq4MMIobPBMeD4bDBEZ4PfOZFg/nmSZ8DPBgjT+IyeDV7FKaHq",
	"Tw5KVqiw+TPF45o8gMOfOeHq2P6oLvFL8a6RJBScX00Zl0ccBJnTj3kiSYa5PNViiGe7i6VQMssExzEH",
	"IfwcqDb76hfeNUQRCPErLA84xEAlwYloTo71W5NzWE5I3AS3eazFpcM3CtYC1OXX/Ja7fyBCkWbd3Jy0",
	"BCEJndfFpVe/Hr46/O3k3W9vPn3669v/efXx6MPbgRYDPgCdy8Xg5bMG0IcDAREHOSlX2VyieQVVVnqb",
	"ZV7+F074/5xK+u7tx8Pxr3/9+Obtp/fj6dHV8Ywc/K9d969v/7dr6SsnVgezb1/+I1QLPc5p89ymHFMj",
	"EDdgpoQfIu1xNp4CjSeSKLHjejBjPMVSiUFYwp7+1XMGcAFUTszPngF5TkNzCYm5XHM2IbHM9RaBKvHw",
	"j8HMkHC9sSwBCXEFWAF420UNHZxqa6mCqLa9YvbWw/hAjNC1cosLCbGLWJay5MBIdXli9B4tO3Z9XeLE",
	"12KRmHO8bFKJcp5yGu/Ocrk4wBmekoQU26ltbsb4nMlJhoW4ZLx62FPGEsB6MYReEAkTdeV8L3wNzKxI",
	"k2E6n9k5eFBdup9XSBP6r98/I/0QyQWWKGJ5EqMpFLoALkcHxI0AK3w4pweZwFVGeHGCq4yUXKG3GYsW",
	"iooILWCooQqcJlT+/NPAq8lUz8TsxXcIrzWiHnAoVtA4gghqWtUMJwKGnoMwWoXvPmpJspu/6AGK18Or",
	"PeJMgsXHBHx3QioxqAnOGU2VcozsC5pCK7Xc3Fak5h86hkzoHP2omDb6B7okSRxhrkFf0mwh8TSByY9r",
	"0mS3Ot/+DhbA+fKIROcbOZEMc0VkaJ5OfWrs7wugKNJT7mUkOldbxigFPgdkSNVQg8cMg8ww6Ikmaerd",
	"GWcpevbUaJuXCxItFPpnwBV66i9jMpuNzuhn9U+zWgdrItywz2qCT4HBCmiz5prVqGZtaq7K4odaHqNo",
	"ukQYqU87aTXM/GfA0lRp2+KQZrmH4kKKSeJfWMbZBYkhRuYdz5WfAZY5h9NMMSPRHEULDkovBw40AmP+",
	"iEBJmvZTlNtvfQcuIMo5kcubjO++bZlgBYIrm2lOHwIv8YDVHKqsEfGKcGGvw0QNvEE6ORzMgUJJfnt8",
	"EBA6UhACzyHwTOIJx3QOk+DXEsdYao0Hx0aJxMlRnSE1+McqbM2NqjP10FeWeQ8HF8CdzlPayiqGsv1O",
	"7qLlGTf3sHKSJVRWT3AVJmFMCRNCbWmdQJrJpY8crorrUqDLBWhLK3YkJMIUKU0UE4qoIidqPf6r5Uc8",
	"JfCrJ+oisQvgnMSA3FbNE0JRhWg98aLq0364ugbp70LH2yLbCgq46cLneLfiq6U6G5NdzXjHEDEehzG0",
	"phLVEYfEiM2qiMH1WD6eUaOM9VGKR/0H2xohXQM56zS3voLyWWhPPdZSwf766PZBb3Dd6KqsTmmG6Jiz",
	"xC31QZVZNIdzT3tvo8IY6qPZB6GBbsRF6jPYB6EZbshyqpq0mzrEeWrwbDKiknFV0DJw57UdoK+BzZo4",
	"CxNGHS6/Gf9fCjHByJoBfOfmOzVFSxVAjYcRYqTfGyKxcLoo4zFwiLU0LCKgsZLX1VtWiq+ebRvdNHs7",
	"wlz6Dr2HCXGoRc7JFlhOY3IHLv/Z0RmZN89ISMbxHCZR8bwNGifmbTtYifU9P/9v87b73CfBrWc03Rl1",
	"X719K1eovrAv7fu6Y0GgAuDNSQPloL8TuTjRVtb7dH4Bi/Z6xuPVU+9nTD7IuaKvp9Y8V4eIM9q1kiDh",
	"wUD9oW+6N2Q281qE/EZr9aAg0M7ya9z4k8I9bkf/4jMbk3/BZLr06tocMg5Cs1fF+dSrjgviOIZ4bNSN",
	"eByDNi8joFK753sc5+qS9YAaS1N2YazWZnDNFa3jfGg9/hP3rNOebfmSBl8VWCHI3+3d1me/sUtduCrr",
	"mwmKlmLBuOLnRsCEqyzBhCq2qw4c9GBd4G7Toiou8u2uaTigbIIjn4mL5+AimYz/Ha6IkGLVAd9pOGrb",
	"5ztC44/A5/AaCzjW5+NxQ2GheHZQu/pcSpqHb9ylM4ZN9alv07F2yxkCd7ORKyN4PUzarH3Dsa1NvAuB",
	"GnOE9jVcBaHvKN5jPtXiTpIYc3tIippzHMEkA06YZ1tvcqvPlTxrhIz4K4ytBGJnJeEQAZWoOiC6JEmi",
	"oz+mCjx6LSYoziOldO/hiIOS+I9tVJNnM5GTKEFMEhYF9FT3BEmmvbwzxpF25UCMiu+VyP1nDhJpVwF6",
	"ogRULfsa0dy4C5/WvQovXo7H6XLPSqZ7FKcgMhzBeJLgc5iJMQelVhBGx8U8PnybR/Z4e+3CYpshiIpC",
	"2G9RJC62tHo7Q8faM6NtQTzJeeJzxxUvoJzruIyYXVIdeVnqm3obvolKL/LqsDklfypypwW7GQGOrHoI",
	"sfUbEYHeH6B/smkNAj//BBg/23+xF//1+c97P+EXL/am0fT/2/trtD/9CU9nsP+37ntc+JF9hzgMoGiv",
	"K+z3mBmnTEgqLY5sEuNlVVUL6QflcI2Pey9ShFYJ/QUC/+49iqw1WU3W3mngw2G5Vu+GFfP0GAy2Jv0H",
	"Djbgse3Q9kLcQm0qbAv1LqHpSAiOfLeipTmxLtnSjTqsrsu3o18YO/fG1+DI7WUDETQLxs5Dd1o/u5cx",
	"NNWVDR1Ays2shNS0RM5YIN8t4riT3phacphmjNe8YgXvMXquGLz847oq9mk/gaOAYuz0uZJZT/PoHOQ4",
	"4yzOI8uaa+/bRdT14q/DtllmJIFn607lPlrZ9BelqHscK/2cPgWo1vNRWFD2PGZzKh8cK+4+bTW4M1j3",
	"OOewuBpSJErvANEjoYyzyJhJb0SEV3bYWEcNFRoqQPmwCLoxy4LYZsIIxGglGGeEPuZCi/wYcUiwJBeA",
	"FNiUhFd57Yweml2qBSMiEKboBzPiDyZ6pbIw9Vxrvlc4ki4DRzFBlNMYePu46Ica/odHN899Q9YERf8d",
	"q5ummpB8ZVVBVNU/GmtDCsbqd0HoPAG7VQtTEwOlFqZE8ncniFAhcZKY4aYJi86V+G62PvKK930pxqot",
	"vxFWrQ90mcFQu+KBaPf8FHz7caeqFrSuoa7VrFXF3DDmnxTM7eakyHpzLSf0RjOCszr1iHsfDgidg5AQ",
	"T+wdakL4kwnaYrPimlk6ADESDM0w7+tRrTslm24eHfOzlsSwatOtjOCXGCpnUkHZU4HncAzqkDzksfJi",
	"WL9R3/Yn9tUJuyj96vzlbL5tfWBzErSyHL9+ddA8YPWrMZFwSDGhCKjS1mNFTt+fHiIyQ2cDuDJ5IWeD",
	"EUKfF1iarMRLxs/FGdXxe+r62bd0BCsSwC9IBJZs2RsnSJolSh3WIcz2fa9lfIaTZIqj80mi9jRJ8BQ8",
	"6rv+WUcNJjgCteaV73KejAbdw3ttA0ZFwnyJTo8/6Aid2czk7HFRNdvoIbyzmMEjxs4JTLQtwxeDoZ5q",
	"NiKKGGBDQP/r989rOdHNdEZonnTGMEiGYiKyBC/tZrhAlwt1p4kGqR7tPxFGszxJkAAqTcifOn4iEAeq",
	"fcRnlFD0y+ePH3Swa4qXRUQURgmh55aRFLDUw6IU5ILFZzQMNe+RZJyklQPpdQIsl/7BmoPMCZ0jlstR",
	"J7Ep1+g95drEwZt6SA2Z84endXr7NuCT6+eD0/b0W0USbzucTClyHEuYezJtDimKsNC+szI62bi0hsYM",
	"x/SrhgrqTVUs55bd2cB8pk7LJGrP8AXjLuTPxDI7gc4FKT/5Qf21d0mo+OGpkkGKt6wQZt578oP50744",
	"Qm7FlCEBVixSVy7FMQw9azMLV9eWVPdacdw1scJ/yCGHSRHx241i5as+VDJ2+wOWLTcSoS54NPELulrW",
	"L4KGMlIoCqU6YDUBb7C3GdobQq7Dw80Wh4o96ghSRUWc+G6DuC0SYNErnLzYSRhqG/MoGqPHJGIx9Ncc",
	"8GymPSfIir0B840ZtfH1L58/H9l5kXoDYSFYRApzuNqQ9STQlRlCttP6Ltp8ghXw+a05WmruL8BVj6NL",
	"gLNDh5d1IvEcWmJAFxCdCyU9eXPmbh0ithYRLwl1N3hOBfCP7gv1tRPtN2aV7hU+Vo+wWDdSyRMkVhxI",
	"bezW85Vi9+d67w5rWyE0PixomrNWHZWWF1ibkba1JEst/ZkHWgAfndF3emeKSmGBMKKGc5weH7oaGVD7",
	"wph7sEAavICenBmbx2g0Mtncc1H+BTIaPT2jv/FhEeRvebf1Sf5d8hyGhr1PQalYmoxauVW7s6nIU4jR",
	"BVFcaZ4nmJt33r/97BeuV8Fl8gd9YpNZBlCpBXvK6L+AsyFaHcAYtzIOe9aNqpank9X1uo1PG2FpRK0K",
	"BikU0+okEcUWNcvSZi9Mz6i1hlUHTsgM1IeK8WJazZU0tqxz0JISnrJcnlHJ7PyjM3pG9UwzAkmsXvnR",
	"SH04+dGoqH2C4G5FSyqEwxt7uhIj5S5hB2W5W/dElcRtzEXhIUm3Ug2OasCoA2qBxSRl3EPrPsGVRJmS",
	"nBQ+XWCS4GkC3tyeFF9NMuCTzCuGfcRXJMWJy39kMx2oR0CgDLieYdAeuz4cULiSEzabCfBUPNL5x4Xl",
	"gIMa+8KoMNTtwRu7UJ51yOZnS0qZMilFiI1zUq4Rb1+AeQVYw4rPs7rJL95jlIsQtq/6WrwMMyS49nC1",
	"eNfDEhIt74EbXgnCkNpqKL2u7UnxxVd9jIfmo2ddxkjrPrXfhoFyt0TJHszG6JEN+Xp/cEpdhki1ilUz",
	"a4PQ3GBAUQOgh/7tnyXktus1jY70ycvhegZyVb5ApDRRIU2Jh2uU0miJSvKuKgD8TZWj0fHLZTDYmnmu",
	"Jlmm10bLV4f9it4cw6wj+6+xvJ7xMNWiIYGZ7/ayqq1v7KYew0y8ydMsHPs16c6ldgFz3W9KPO9+zRvb",
	"1liId7DQWkJbPwathOxo92tYDu4XoDImiGR8p6zbBfq1FEAKehdxPGE0WXoLcGiHtxHL3LaMQqY+29Ne",
	"uvLJng6D5pDABaam0tQU88q3JFQXwqa5FeG4zbW8IwmIpZCQau248GGtqNc6k5VQ9ARG8xE6W40IECyF",
	"sRK5xmeDp502U09kYQPSvsW3o0XYFtc8xDK0IcXEq2+7GMmiqMzg//7Ae//a3/vbF/v/vS/Xz4c/P//6",
	"F7+QXjv9+kUrZ5c896smQr8xcUrUTUa4q7NfCRuxf7q3ja7sQPpEvPj3XPx7IWUm/vHvFNJ/K6Ei+bfk",
	"mAoCVD59OR6PfvxLJ0q5GkJr4oxiOqEIj5hR6AjWCNCCFYNMkdMhsTj3I8usD781LHIjMRfmxqkN1kdr",
	"h9ZdSxwFA9ig4OHG3IzJojner7D04Na5/TWg+Ba1A85hubbmq8fut9kTX7rqVsqE2CHbl2XloLu/kLu+",
	"YALkhgp/BYz1fofE7wssje1JmJKWjOuCAZJpm8uoEgBkVztsWPj1tz1D7/ybvwC+qWo/pgi7cey6wjtc",
	"T6DN/iyXzvH/1MszN1dj7XIBFJmpb1pererv9lZZM8OPblpEzXy+dv20+saHwXpqJyB9yS423KW95qSn",
	"lKytKOHEspVzp9WELRdprIueGaHln5jCKGbQLZsWkwT3pI1wfrVfXwsx0bV66bw9k1a9r2OGTel/+83I",
	"i5cuUqlPtYlqLKEzMlZddIQSBVFdo3k4oExOqr986RVzciIVg51/6DZLqbPIEhzpS0Cdz03fDmEGQcRk",
	"qN/OKOSptFR3x5nKgzr+tTCIa1OgjSUy/iXtzyrj4FacWDboTK/e2IrUUoYDmifGyfBSO/46lvrouevr",
	"uWtBvaq4tnLuFcunXlRZLqdgYmGX/krZxEYyaBFQjayvHzGKptgU0TTa0xO5zGys2dvPeP7UX9trlwEg",
	"a/o/NdGYWwLW4Y6okYEtVv1xK1onjuOk6l8J5duFDckt/pXhAHRUVa0Uh5I9tB2DLr0BDxz6FsS1g1c+",
	"KRLiQvsUby+8G40S7AutUFxBIF2LGulXKsr9ZI4lXOKlCXxgGVCckYmlluZHuMqAEwVanOzZcqDmSU72",
	"9KheM5DCe2/zl4qL9aJWl0wvTRNDXBW6qy5Wr0BQ3Z9O9HHby3JpkybMek0dgklpazM/n+X7+y8i3zZ1",
	"art+DL1MXRr+Q2efMPtvP8RAaICBzFquQosUnaFuZmT/qqqVr5r26SJpqLS4THQTBiKXxzCHK+/N8n5W",
	"SWds+yBYGN4Z+coRs6J3TlMt1Lk9E1vzOVBg3LxzYbcz4cH9ZBwmimNOUuftmuSFu8ujOrjXW6dffWuS",
	"k0Cd85r1fQVSHcAe9jlCz4r9y2vANQTEFlQ7PT70RfwfmnQEHR2sRTNr6XNhu7xunTTGxmfGLCnZ2F35",
	"pw3mX3WtdqUOtLg7P+N5VYddjSQ5ByTxHB2+QRkjSr6zwtnx23ejxpLW4Owt5g2s9XhD3wJGxy4NUeJ5",
	"P0NHSAf8jMX5IZ2xfumrXXaZfgmrp4Xh2ohRdbEjUAbQcckOSd4nkFZKJTZptoKgP3iSV20HXdGslbeH",
	"ZlDvztsS4grO2yfpj9GaHanyaAm4z4r1a26gNrbnrw+3PX9eoIr75wWY4u2uho/DRCXPjtDhDL06OlzV",
	"fYhwSXc1HVInfNAYa5+ekl2cqmU6VsRFjpZJNvYPHBPRHLkYaE4Zh3iEXilt1RTaU+NU+lswLpA9EJP6",
	"nNrssCmgM5qwS+A6aFWtz2g5Q4QTuWD5fIGiXEiWVlelhkvxUvshgbpcGyJG/mDVGSdA42Q58Utnrwqt",
	"U8tmNXuN0kNNnng8Qqc0Iec6p51IFDMQegFWHVtWjDxEntGUzBfSFYwye3o6QqdW4xcsBZNtKJwB4PQw",
	"sHwfcXrlqQxUXfgIHWBqJ4eY1EtVtcZ51HA9dEe6Cqx0lzGqLda7686GKn2orwB+t24iUzdyUw6ieu3W",
	"xqYSLEHISaUKsseXMOc4ViqGYqxA41AKuHvRWrMaA4Un8WrPrinDiY5od+XzSDRR17rotabXoH4uMWIh",
	"ZWZ0NZ0Y6V4nZdJr2UqS2MZz+q2JACFqVfBwRn4FrS//81KW4W5TwBz4O0etTbpsuRz9tLkeRuKofTXF",
	"G20rEThN2ocp3ggP81XfFyPYrGY269oKOpj/1dHhYDhISAQ2FtBO8CrD0QLQ89H+YDjQx603KV6Ox5eX",
	"lyOsH48Yn4/tt2L84fDg7aeTt3vPR/ujhUwTjeFEaje7ndLMVmDJ4Nlof7SvAWdU+MHLwQv9U6XIyVht",
	"cxytdGOaG7dgkdt1GA9eDt6DbHRuWukS+nx/f2M9/hpzedr96Xz12uK/Dgc/Pd/3yLWMme6yRV+mUmMM",
	"raTY2rjay7F6tQYv//gyHIg8TTFfqoMgQq7y8uryyqZ/NhzK2ONdNr0a2hyIrrIZPgpFYN+bV4a19sV/",
	"+HdSvjJudJb9OlzjG9M1eL1PTKPer1+2iCtloTAPkpiKpQkx3WR/2n/Wfd6rfSx3gVJ1JJq703VYogmW",
	"LojEhAcjtHgAplqZ4XQg5GsWLzcL47KmUrNF8HMD2c1NFjzMm5/j/k/dHxW9dnd98EZVN0ffPPkV2jC+",
	"1v8/jL+aBSZgFKU6WrzRv5doUTuunzxNOPRdcXWpRa4dsbM8SZYPFOZmqyGYD4OcMADS/ccbcJvTmIMM",
	"H8UKnyOuWEApt9kbMaiK+saME250/iV4r8a2FnYrCpiy19sTgvyNsV8dfEBshnaICq7x911gRG23u0OM",
	"EKs9WTn6zbPa4tTrqw0w3CZqVOk2cjX/HybFEJ34Eb7fKaRT4D2k7I/2xUdZ25pX2kVtA9dvUuJGaXHU",
	"d89/7FrG17kA3l/Qs9i6IP1EvrR4/XuV+1BahdiOzn3oHcmc9Np8KvdQr1dx3IkOz1rRQfeW+R6QAcdx",
	"D0wIX9SMJSRqM50VnOTIvfnISop87xAz0VBd3pKN3Gu8q/CdrESMu2c8bjHja3MGnbxH4mhhDvMdZ2l/",
	"c4M94lgP8L0wHrVXZHeuQ/13rNj4OY876c3wHllixGcWwIdnQXzA8vvBB7NXhw+SdaoxOnJAOyK92qmO",
	"/t+SXtqofeq1Am/WBVR6UnS5HB+jKLHEhFUMhoMF4Niqdicg9w6Mg682cZmlaouoau/k3/E0iuHZ8xf/",
	"8fN/oiMsF38f/yf6RcrsN5p4MvH0au6tghPwUrkUIlyAK4RrvQSbR5lmxzLNzkWUVuGkxR1l6/lshxi5",
	"YkG97WQbn9V3tOZU97tBriNs9QqKcqQ35G5/6/7owBUUviOXVuYQoYvQ9JY4dT/uEr16C5rfm4EjBPmw",
	"ZysE1f0d36EH6dwKH0e3rL9RCf1Up6TfGwK9/5AJ9H1GSlOaoJtA6y4TrWLgqXh0kfRwkehw5W9M/stF",
	"yCXSIvzpMNztUJZaPPSWI5FsF3rvOVZoyUbmcgfQmOyioEW2efeDlhZzgzmtpGgNp1iBiF1Cor6a35+I",
	"6Ad3WED0w3N/hzfuQYqGoWPoFgxv4jQM3KZxVKm40sXtq9VZHvk+FuMKQELsv4Tvg3dsaXIa1XBkR8jd",
	"LpjU0XZrgkNlmt+JXJzohl3tKCEedmBzKy70IEjja+wKQ/Vi/K0H7eH/lam+QzGg46aGpIFWIG+FtH6f",
	"d0iJCHdBTP3e4spF3Izc0SPhSYkcj0lPO0x6+kZEjJZUqZ2Kzr2cpQqJvz2H6bBR3dL0HZY5pwgnCYqJ",
	"kIRGpauwjOGwzRr1UTGOFCqwGSJSlAenD+bPHPiyPBlTAotcwKB6GF0FUR7D1XZy5W4XrbaNS3fDULXe",
	"tqHHSDXO0t3aKHYep+ZHhscwNW+YWthIW1apnfu6nhV9zmzVAvN6zl0xjqaGYcbbpnJhi+U2ibp3jTc7",
	"4a8lsCyEquAazzGf4jnsRSyxjaODEFSqQLXIKZuheYQESEnoXPhA+N4MflCMvX2YhqYMA9lCAJUQsHC/",
	"PcBXSixYkNviXzU4ZxwiLEua0o67rgZdJw7XyyhuEez1icLA9q98S4CuFK7pCWiF4vYrhd5u0Zo8+eD7",
	"Qb9ga/VsE771ckBh+LotbxqiC8CJXOgSuEH6oJ8iqWv7L0DXFzOQQ0SgPNMlv3hOqSmnW4flL3r8Az1+",
	"H7noEzuwYG1GnLotLCpjml3U+ha1qUvH9QZHj1r/eKUZiwcDKw2lvrE4g9V2VhZ/aj93hR1UmsQ08KVR",
	"bd20abbmabzSU2tpOkVThmx9fFcYU92fokmVT3dV49xAbd18oISnN9aO42WrPXvaUPUxbtbnMeFVZA5c",
	"h1V6Or4uv+rhJOl/X14vMyxEpT9dxpm0gpq6EtaPUO9pF7ghpsLtLS07P/mUi+Lyfn8enD7YEnbk1BBh",
	"B+yrDz14kF6cfsfUbVLh9QNby5QWJBhj02ZAjHlOe4pmy2P16hZXvDsjt5eZF+0oOy1VK18acWHQYZja",
	"XvacPsnjnIYERVOt0BBwfdwP2GzNDY4W5iqD5V3ss3YbxtemD/bXtqJQxznd8lXwDeb6c69lEd0+4nlL",
	"dhb4hkzZ3QdM6bHa5qawbrxg7LyDJOf0F/3St4CBD0AXV8Duoq8ig4jMSKQx3hzhwyazdpMbxfrxtfrf",
	"xP3GcmndOS1kWB3Ob+bFb+Q6eAaqbHuL5J1FEuSekBxwWsf+oqHClFDMvQnwDRneogCyp/SABfmVna6P",
	"8ka2nJSKdF1fb1rJ64h+aG3DRpN/rQc7KsY6znV/n5valVaL99uW3ded3UHNi81a+n0MTx6V3sCoamzg",
	"eQIPX733OACGYfeJHzHeg/Rhxa0jNXv1YfDiY7MvQ4OA+A/8Icd1hnYcQILtmQZK03pfDDNG9w2TnvWx",
	"arO0xVhfvy/asiajGguQE93x0nQz8QpiYeQ44jBLyHwhezkZTwVwtMACZcB1m2RGRdnbDOHABTJtfohA",
	"d2JWvIf+hR1Tkz4o1eH/fe1eevT9auP5LKRr2hvw0KNPpyU+OGQuftoVawzTuK2yvNt5cCVcybHuG1Sb",
	"tlubgxlwoBHcgYP2RfdH7xifkjgG+mBodMMHXPgfPAjfj8KOr82/eniDCzz2XaQd+XAtKduwgrd9ZLoD",
	"j28bboQ9vRVitT1GFWZSD16R2zlz8tsOp1WedLs4+WMQNbTZRqSS0Lmka7A4b/iHAFmhGL2Z1mscH5td",
	"PZIYi88GlhvkPuNoAZwv9zJiYle/jevgF/r0To6IDZLd/HUoJ7irwL0DE7zgoeK6RXh5lDYq8gHLh9ut",
	"7eTkS3Q31/wYsgSbTsqmU5AwqV7qhzm5AOqiXpnpmbxRgqBHFt86MXBhPq3Rk58XgATLeQQoBYm5ArW2",
	"YemvR8hwV5TmwrSwXuALQDk1j5UcbE9nFIioNGNPirG7w462QLX0Yu8fxXrwFGoNDfbZ8+2TtCOuO/IT",
	"bYl9h0kCMXoCo/kIYZRx2LMURftOTRI5xAijGSZJzuHpndWncRe5zNMz9Gl9yhaT2Sxo2HxDZrPt62Bq",
	"lpC1UC0PsZmzm3vIzEONlFYbX0tL21Hk6VbN2W8gISlxy7uPvHXd+7XAPJ5oDeXbER5yT6reMSQsKq18",
	"SiDQFlf7jxFqyAWKNmBCa3c2xhKPmql8mMd1xb1VQNH4izRMh245usxHxgiVSCcTal+aNQiHBBGFlDeB",
	"8c4yRB5NBJuipuoWooCdAK4y4CQFKnu7l6sXnKQZ47LNYH2o3zjANIKkC7dPKfkzB0R09awZAa6Yn9Jm",
	"zDQo40yhQwCjbx1750FDO3Gkl/8tWbnvt8tEgxMxOmeEzu3pVsNozA9B47jBqROJZS7uOU5tTlCsbdoj",
	"LNr9CPvCgzXe1/fpRZpv2EpRnDKXW7JZWoK8lvb/fEuzH9tpfPh8WJwzlw43H5hVYJdXx14bJYMay6GJ",
	"99UVRsB3jdYVBcx4ott5/ZsJNL5T57Xd/KPzutt5bUA1Qh+JEIpb23M2SodSdVx9QeRWapofjCpI5XDj",
	"2yDOw6YykmBJLsAVSWytKmGn3wAvOM0ShuPQdekwKxzOPjEKH7HUnvzuUj5viudDo0FGOMNTkhC5LI96",
	"CkjkmSIQECNC0SyXua7FkQAWLUZvW+0owVrQ2pmS2Yd53iapZjhI80SSDHM5Vm/vKeralp5RWUMd+r/R",
	"ZIkwUhcsATQjCaAMOMo1BqDLBXG2hSkgBZQYnbnBzgYK7H0W20j02KaZ36CtEle90qolwClIrIH2ENm7",
	"seG3f1C1wRsT/I6DjAvSPBxc7ZUNbPbgKkryGPam+vpYsbAwjrVnHZxIPC/Z/DaE2AK75nBXfqxHBN+p",
	"NCLUWSNMrfzxgyhAi2aMV/zgDRPXmtkTHpl2HLFsuW0L9orrB4S0bgFn5XXb1IsZbkvWqU6sRkdrCT/q",
	"68nmJKADli13QEfUNPeUjKilOVWNF9ryIy3ZhCMZ66uE2KwkK16d5aZUo1SDvwmdZ3OSt/8yV7V/sa1m",
	"plguSm/67tqZml1pXAs5899U1WmxcpkfL2Xd3CA2ZW+46d3V4kZn5mRVQ99MrqTV+LQG7iwvn9UfMQOh",
	"tz/PMcdUApSlY52aqCCkVXRnzUKMI1BCUcaEINMERuhQIkJjheUgkK4PqEYoV4HsmJKkoEhjhJNEHYNe",
	"EdBYu5m/c6TdbYLmN2vXWvfucbgALr/xMNNjvYktJ2GoKTaQhaGGuUmMxWNs+L2KDbf3ZiOx3orvETof",
	"T3F0rjC9pXjT0WIpSISTV3HMjQe9h0Mn4yDInPqswLvpDnRiNviBRZXbs9I3xG4MYbMzrXlbwCDMAT9Y",
	"7zpVR6ytLG7rklnrs7Y8JASojoZxIodPcbKQemSK60QYfiD03Ehiq8inq5vrJ1guEKG2y4Kth65RknpC",
	"g0dn9HNhE3NjqZObAmIUkDvsGE2XaN64zUPTBKz4kuVSkHi1bPQPouhQoQAiMhypiRsxjmp3neRiHYfW",
	"ljIjLHH4WBht70KL/N5MyjWCtFmO3YPYR45363uGbXbBEEm+RAvgcP89OZXuT0KwiCgK7rgVs6V1/FQF",
	"I0u/mqT7pnJDlmb5N2Px2iXhb0xH83RqohGtTAQxOj3+gDLMtXnIDFzaBIIL4dLrVFfK6Vy36K/VC6uF",
	"WOmGGRIEwqjwZJesPbamFoFKhn/4xqBObc1GQgLdeUyN8ITpGXDydHRGj9QvZrPCRHNZ7Hs2Qm+LT+Aq",
	"gsxYHhIspGZRCyxQSihJ8xQJ8i9AMWRAY+FyHHMaA0+WCs+nCYvOdSgTImmWgA5oVmsYndF3am1XWP2M",
	"LhlXYq1ZwMmLynfD+lREoP/4+Bo9MW5QYwCxS1PrferjcqbGzJGBzEcHz1N3eltzIQRm9Gd8qTebh00s",
	"JsS7jbO/z9Kwuxyeu7G5+Pkq2Rxfm9EbvTFXEkCmTF0h7K5gY3XNFBP9SQtebl6QapvRG3jisU8EkRVP",
	"GX9E1Qqqami3YEQYX4ffkGtqpVOpvSvforJ3wBQzMnw3dGZKLcNCQDpNHPcxDyA2IkLzmrthd3rTOyb1",
	"XvadaUxBEhLZVd9zInIPVaFd0jWHW23XxE55U5a8i9oWHUUJTUGEY4gY3+IlLaa4td/AlgXgejRXhPcx",
	"JmWTxQ0scG8SxGYRenxt/nHY3genKIqyxabNfcp9PMhMtZZCFTuXuxw2bNKDG+dpFq6ekadZKEPTJ1xJ",
	"LM7vU3eksm9aZSe+Gh15miG1+Frm5U4J4X2+BwZwOsau2rK1gNrd9NYLhqipo86nXpK4uRzIz1icH9IZ",
	"a0enSuv4+49TG8CU1zg6z7MVB1MZ5P1EocnQ0lQxLEpMP9WGSoEvjG9qakcx6lw1x3F0w96s43k0zjhk",
	"mMPkTqXFI7MIT8d+s6gtWhgbc9q1tOXvKmCIsnSazjwV8FiVo0hoUCibECENdYy0GcIimLanzw3QUVRA",
	"/SbyYAV7nZPYBDTeHwQ+LZ3X2woLtjMfVKYqtPnt5sH5p77htXnUr2533SqMpRoxUcsk2ti1M82BbtEp",
	"rHFRAk2hPDq6S2xvbsb0LHrsx9XRj6sv7Pe3x2PNjB4SMY9M35wH10Xk3rfROmlFjM3zrTacuIHlToB8",
	"pAj9aXev5llBlNhMPkjrkbG7bJz1nfXBKqLuWlzzNsXL9hKGGJ3DslKnuxY36cbzBZKYcUoLVBGPuK18",
	"gtWJfoWluEVeQVN714DYbLWdO8hN8+xs0C5xNDse+w9160bMekhr54E95HbArYd4J0bI+uZP/Iu0eYA6",
	"yU/n7eE4RoyjPIuxNMavjLMLElu6M9SGsUrWZMouACmgwhUROnBcveajPydBPN0F8TkBuVHaUy8k+8CE",
	"m4qC24nbvQUg963+x0T3KRhfl/9u9SiqUzy2nQ22mMSjkw5Ojw999EytdM90blBvDAcLwLG+wNeDIv7B",
	"gzox4RBJJXWdvGgtU/X1YWKQTaw+PT5UMMCoAscZSapFAgvkugNPZomH2xDvxhbbuxH9jpH8Eb9vjd/3",
	"DrU3jtUcZqJw029VkskD3tRjmG3VM6XGV/MEmqIK7Wl+9MnX7oGCV1VU0HAK+1clq/lRz2hZKvIlwojC",
	"JXp1dGgkTUIlZ3EeAUoYnSOeU6rTkBxeiLMbWdM1HnMwtWrvApWPzdwFNm9DDp4JO8saaYcehK+KusgE",
	"DD/i/0ovNZMp1P8KNAomj+7sFpSpI8s0IfT8G02208nMNkpD4mkCyCorvtiwxAk1t4iyPTHgeme4/db4",
	"UbvQ5jZSj5p9cBfM7E4gi6JaxBIoYtx8bNLpWKVmo5FMDXbe8FokMJPHMDM9vcbXnMwX+u/W9l5+6WSH",
	"zb2mIC8BqKY/D7mXV9GOSNRsbbPtx8LWN4nLlaAnEcuTGE0BAZEL4Ai7SpuMF9kP6PDNU3+xTYtwd7Ae",
	"Gx2SYQ4IzzGhOv3BBzV7CdZd4wNtprYacaw27i1tOJALDjCJmYIr0DxV2Covmf2lfPpleCON7JorQlUJ",
	"JvQSqA9sXob23U27uxXuRYTU+epYLsTQ5HuDybVGRNhqAibU17rAorI6jO8EWFELsjwEIiEVHrwsII05",
	"x0vfXVpjeZlBqGGoRNGMXMHmlqWureJ1Zca/Hg0R6moZSoZ+wBrsP4zQ70QuWC7RLOeaDNhyfUpsYBTh",
	"SOY4WR0rVHlfT95ebKmxYDLTJnPFoBWpQDOWJOyyrBU4I9xkwSvA5hlTu8DRQleiQSnweaVFp7emqPp+",
	"Yr5fc2knC3ZZxEimRoaP1DLkAtMq2sVYwp4kKYzQIUURFoByAbHJbBOSZROst2Cwf2jEdvW7K39oNmlp",
	"ri60mAJIof0ntoFUUe0j3PeA0JXqqUWZ/mKBvkr9jZTvCpeQzK3TuzU14w42ZiA4uKvkDEMXQ5KV3VzC",
	"5g8+uUht0minug3l4QxNmSJytmYqpjFy5AwpcQHSTC6HRQnVJHG3abRrucw72Gzjxk/Daiu9iULm/FCb",
	"lfqJvl5KQEVTcA6SE7hQd9gWGFHkaylB/H1/79n+8xfu+hgDfbnT40br7wxLpe4MXg7+zwzw5MnZWfzj",
	"nvrP8B/oH0//36d/8ZOKHVXZu02flFAlKzdVzYNxYH7c+wB0LheBqQiVP/9UzlTWuhkO3n7G8/pXzU4o",
	"H7CQex9ZrKN02l9Wrz/f/3lXkMkwlwQnaJsQct8bLKy3q7khGm4D6i9MytVqJ97Si2W6lFdKJ7kOCYXQ",
	"GXCM3QvP17P97RcmtVgEV5mmqHran7c/rU2tgBhpFEOfmEQnWBIxI3iawJ3wy8aF8vUmU/jS5A6/QLgL",
	"1/1mD1/6eA0KJCFC62LfBC3uQzV1CuV3STotCVvthOslWV5koEyi2Qqp6kladkMKVlRWaytGQtMA0xBg",
	"1Si9gOgckRlaxfddNyncmkWS39YauVoNyQy4i2LwTVl9nLRYxoiQ1T4i2y8uFFI1LS4lJqDygaqbxrBm",
	"VUpddBFh67gpDGnf8yXyXZBcAJ9UYjA9VmYzss/odWOV7h7a7ut2+LVN/uvTDSGxDGfrSCwrDcW+rTrO",
	"d1KCrIX3zxkF9GSam5KoSv4qYq5TvFQ3EF9gkig+//QuZX5PKPQjr996teP7QxXXpyFlZeGjWv/ekPHw",
	"1Pf+FglMOZ/rPVXM2k1vEKPV0sm2gP8DNpXb/ZetmAMQeCQP96Q1lLmRguU8Ah3To72K4+tKb1LTYCkc",
	"3fOO0Pij+uo1FluN0q9NdAxC4avnDppGdQqSxkM6xXfSx/M+X9UZaUBIW3Sf35voIYORVbW4Pk+BsRvv",
	"/asn8M7ZuBObqdWjUfqQSrbVTmZ6lm3XCNaThG9mEbGwZkHg77QJWgc0XSu0eny0M8iaQUxQgvVBa+Ah",
	"Y3vV/mrK1P+NpxpVZjujlVYs2/VfZJVWLmime7mgJzCaj6zLyaDMgrFzuwuIEdYv5vwOVB2znDYi2cVu",
	"i8QKLy+18fIPo5pnfTPerCGTHfBY07NfTU+XS7FahvselPN0Z11W9LwHeTu7qSNaw+IHXKN7O+lAOqIK",
	"myq1hDZKid60kqgAKQmdC9sIZpJxJm2JuRbjgpHAjop3N1KJrIhnbUMw38yekNcG8lmhtdyeqVdUd8U2",
	"3Z71QdRzF5EYHvA7SV2eg2wDwp2Q3NxfDSuEritr0XW13ioh779xkoObshGK7GqaDNsQoWh9boqhxCZY",
	"mdhw1pzrUGWNUCmWtplpUSzlQs8fCMU4nO2ZlpOdksvNWMuG7+ENSqb4Qep4hqdyyq48FdtXi+51W8fb",
	"cZh5NPHUH/WVGXt/cP/Kij6E0rNBohzi88GDuIsaoxVh6P2BZTTfRU2wYrf3jK1WseOx0OjDphHtNN58",
	"1BIa9Vm9cPOUwZtkW94imGS7Zp9g+rXE84dXQHklZksaRHBYpv9/N5YYU4NBaXzboV+f8Xy9vmYbrUAU",
	"wK8H7Epo/8A5Ae6qiZrUeLaC9t1EdXwt8fxrt8Rs0LiHFXzG+Er+Z48kLA87VbRqs8VzH1hzB1uf13vu",
	"YYHbkaPtMZ9WwvAgJenAEew4k1QWjGaNeBQBMs90i6dJpv1mL68D3OxEvXnA0vSIb68gWDH+IVU6wU1r",
	"gqn95NQVEMhKL6HumeWjJ3/bvoNVgxpdYoFwwgHHyxX/+y6cvJec0TkyKxFSsQ2TPkhEWahrV1cIopwT",
	"uRy8/OPLSknfPEO1ExTVIwxXSzK4nOBzi8chEqgx+UTtfquVTMtZfEWx8Dm8O6mexB2DvcgUkgtAdnWE",
	"ComTxNwiUuKt0nTzLFQFvoV8bIlqmLH7E4vNkCoOMVBJcCJ+J3JxAhEHr9KVC+CbtSzfDbHCye7swO3E",
	"waInpq4TM8K2xIeCdQuBkFgSIUnUwuaOmDBJDG8v1Bq3hbHlDKWufsPS7/xOPRa7lLXUiWliKRBo2A0N",
	"6wIaZ4yYikcpYCo1VyvyI3MB2jcWRoxc4DnsGWCOi/laQt/V+8f69RP79hYpzWGFDFdm1sCpjirhSnak",
	"yQ4bHXjw3AQBcHm/U3J2LdPnFcggURxyEIGAt7YcN+7YU0OetseTKtMEOJGvqo71Fa8QT3Viant1cnw9",
	"+OelnEh2DlQRZ6WLTLEg0US/bn+JGDsnUPuJkbj+jsBpUv6gqLw+D1+FgUJYMnnO9rYPhoOcJ4OXgzHO",
	"yPji2eDrl6//fwAAAP//6+vNBD+vAQA=",
}

// GetSwaggerSpecReader returns a reader to the Swagger specification corresponding to the generated code in this file.
func GetSwaggerSpecReader() (io.Reader, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	return zr, err
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zr, err := GetSwaggerSpecReader()
	if err != nil {
		return nil, err
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
